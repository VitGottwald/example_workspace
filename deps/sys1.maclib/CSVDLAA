*                                                                       00001000
* %DCL CSVDLAA_INCLUDED CHAR EXT;                                       00002000
* %DEACTIVATE CSVDLAA_INCLUDED;                                         00003000
* %IF CSVDLAA_INCLUDED = '' %THEN                                       00004000
* %DO;                                                                  00005000
*/* Macro made bi-lingual on 17002. CBGEN compile date 15295         */ 00006000
*% /*                                                                   00007000
         MACRO                                                          00008000
         CSVDLAA &DSECT=YES,&LIST=YES,&TITLE=YES,&DLAAHDR=YES,         *00009000
               &DLAALS=COND,&DLAADS=COND,&DLAAU=COND,&DLAAJA=COND       00010000
         GBLC  &CSVDLAA_INCLUDED                                        00011000
         GBLC  &ZCBPRINT                                                00012000
&CSVDLAA_INCLUDED SETC 'YES'                                            00013000
         AIF   ('&LIST' EQ 'NONE').P0                                   00014000
         AIF   ('&TITLE' EQ 'NO').P5                                    00015000
 TITLE   'CSVDLAA  - Dynamic Lnklst Answer Area                     '   00016000
.P5      ANOP                                                           00017000
**/ CSVDLAA_1:;                                                         00018000
*/* START OF SPECIFICATIONS ******************************************* 00019000
*                                                                       00020000
*  **PROPRIETARY_STATEMENT********************************************  00021000
***01* PROPRIETARY STATEMENT=                                        *  00022000
*                                                                    *  00023000
*                                                                    *  00024000
*   LICENSED MATERIALS - PROPERTY OF IBM                             *  00025000
*   5650-ZOS COPYRIGHT IBM CORP. 1997,2017                           *  00026000
*                                                                    *  00027000
*   STATUS= HBB77B0                                                  *  00028000
*                                                                    *  00029000
*  **END_OF_PROPRIETARY_STATEMENT*************************************  00030000
*                                                                       00031000
*01* DESCRIPTIVE NAME:  Dynamic Lnklst Answer Area                      00032000
*02*  ACRONYM:  DLAA                                                    00033000
*                                                                       00034000
*01* MACRO NAME:  CSVDLAA                                               00035000
*                                                                       00036000
*01* EXTERNAL CLASSIFICATION: GUPI                                      00037000
*01* END OF EXTERNAL CLASSIFICATION:                                    00038000
*                                                                       00039000
*01* DSECT NAME:                                                        00040000
*     DLAAHDR                                                           00041000
*     DLAALS                                                            00042000
*     DLAADS                                                            00043000
*     DLAAU                                                             00044000
*     DLAAJA                                                            00045000
*                                                                       00046000
*01* COMPONENT:  Contents Supervision (SC1CJ)                           00047000
*                                                                       00048000
*01* EYE-CATCHER:  NONE                                                 00049000
*                                                                       00050000
*01* STORAGE ATTRIBUTES:                                                00051000
*02*  SUBPOOL:  Caller-supplied                                         00052000
*02*  KEY:  Caller-supplied                                             00053000
*02*  RESIDENCY:  Caller-supplied                                       00054000
*                                                                       00055000
*01* SIZE:  Variable                                                    00056000
*                DLAAHDR -- X'0010' bytes                               00057000
*                DLAALS  -- X'002C' bytes                               00058000
*                DLAADS  -- X'003C' bytes                               00059000
*                DLAAU   -- X'0010' bytes                               00060000
*                DLAAJA  -- X'0020' bytes                               00061000
*                                                                       00062000
*01* CONTROL BLOCK CHANGES:                                             00063000
*02*  CSVDLAA                                                           00064000
*02*   5.3                                                              00065000
*03*    New                                                             00066000
*03*    Migration Considerations: NONE                                  00067000
*01* END CONTROL BLOCK CHANGES                                          00068000
*                                                                       00069000
*01* CREATED BY:                                                        00070000
*     Caller and passed as parameter on ANSAREA keyword                 00071000
*      on CSVDYNL LIST                                                  00072000
*                                                                       00073000
*01* POINTED TO BY:                                                     00074000
*     CSVDYNL parameter list                                            00075000
*                                                                       00076000
*01* SERIALIZATION:                                                     00077000
*     None required                                                     00078000
*                                                                       00079000
*01* FUNCTION:                                                          00080000
*02* Maps the data returned by the CSVDYNL macro, LIST request.         00081000
*                                                                       00082000
*02* The returned information consists of a header (DLAAHDR)            00083000
*    which indicates how many LNKLST set entries (DLAALS),              00084000
*    or jobname/asid entries (DLAAJA) entries, follow.                  00085000
*                                                                       00086000
*02* If you request Search=BYNAME you get DLAALS entries.               00087000
*    DLAAHFIRSTLSADDR is a pointer to the first DLAALS, and each        00088000
*    DLAALS points to the next (DLAALSNEXTADDR). The count provided in  00089000
*    header field DLAAHNumLS should be used to determine the number of  00090000
*    exit entries to examine.                                           00091000
*                                                                       00092000
*02* Each DLAALS indicates how many data set entries (DLAADS)           00093000
*    and user entries (DLAAU) are                                       00094000
*    associated with it. DLAALSFIRSTDSADDR is a pointer to the first    00095000
*    DLAADS, and each DLAADS points to the next (DLAADSNEXTADDR). The   00096000
*    count provided in LNKLST set entry field DLAALSNumDS should be     00097000
*    used to determine the number of data set entries to examine.       00098000
*    DLAALSFIRSTUADDR is a pointer to the first                         00099000
*    DLAAU, and each DLAAU points to the next (DLAAUNEXTADDR). The      00100000
*    count provided in LNKLST set entry field DLAALSNumU should be used 00101000
*    to determine the number of data set entries to examine.            00102000
*                                                                       00103000
*02* If you request Search=BYJOBASID you get DLAAJS entries.            00104000
*    DLAAHFIRSTJAADDR is a pointer to the first DLAAJA, and each DLAAJA 00105000
*    points to the next (DLAAJANEXTADDR). The count provided in header  00106000
*    field DLAAHNumJA should be used to determine the number of         00107000
*    exit entries to examine.                                           00108000
*                                                                       00109000
*                                                                       00110000
*01* METHOD OF ACCESS:                                                  00111000
*02*  ASM:                                                              00112000
*      CSVDLAA                                                          00113000
*           DSECT=YES!NO  -- Request DSECT definition                   00114000
*           DLAAHDR=YES!NO!COND -- Request Header record mapping        00115000
*                            USING on DLAAHDR                           00116000
*           DLAALS=YES!NO!COND -- Request exit record mapping           00117000
*                            USING on DLAALS                            00118000
*           DLAADS=YES!NO!COND -- Request data set record mapping       00119000
*                            USING on DLAADS                            00120000
*           DLAAU=YES!NO!COND -- Request data set record mapping        00121000
*                            USING on DLAAU                             00122000
*     Default: DSECT=YES,DLAAHDR=YES,DLAALS=COND,DLAADS=COND,DLAAU=COND 00123000
*     Notes: name=YES  => expand                                        00124000
*            name=NO   => do not expand                                 00125000
*            name=COND => expand only if DSECT=YES                      00126000
*                                                                       00127000
*02*  PL/AS:                                                            00128000
*      %INCLUDE SYSLIB(CSVDLAA)                                         00129000
*                                                                       00130000
*01* DELETED BY:  Caller                                                00131000
*                                                                       00132000
*01* FREQUENCY:  Created for response to CSVDYNL LIST                   00133000
*                                                                       00134000
*01* DEPENDENCIES:  None                                                00135000
*                                                                       00136000
*01* DISTRIBUTION LIBRARY:  AMACLIB                                     00137000
*                                                                       00138000
*01* CHANGE ACTIVITY:                                                   00139000
*   $L0=DYNLLCBG ,JBB6602,941231,PD00XB: Dynamic LNKLST                 00140000
*   $L1=DYNLLCSV ,JBB6602,941231,PD00XB: Dynamic LNKLST                 00141000
*   $P1=PUX0531V ,HBB6605,970915,PD00XB: SeqNum comment                 00142000
*                                                                       00143000
* END OF SPECIFICATIONS *********************************************/  00144000
*% /*                                                                   00145000
.P0      ANOP                                                           00146000
         AIF   ('&ZCBPRINT' EQ 'NO').P1                                 00147000
         AIF   ('&LIST' EQ 'YES').P2                                    00148000
.P1      ANOP                                                           00149000
         PUSH  PRINT                                                    00150000
         PRINT OFF                                                      00151000
.P2      ANOP                                                           00152000
         AIF   ('&DLAAHDR' EQ 'NO').L0002                               00153000
         AIF   ('&DSECT' EQ 'YES').L0003                                00154000
         AIF   ('&DLAAHDR' NE 'YES').L0002                              00155000
DLAAHDR  DS    0F        Header section                                 00156000
         AGO   .L0004                                                   00157000
.L0003   ANOP                                                           00158000
DLAAHDR  DSECT           Header section                                 00159000
.L0004   ANOP                                                           00160000
DLAAHNUMLS DS  F         Number of DLAALS entries which follow          00161000
         ORG   DLAAHNUMLS                                               00162000
DLAAH#LS DS    F         Same as DLAAHNumLS                             00163000
         ORG   DLAAH#LS                                                 00164000
DLAAHNUMJA DS  F         Number of DLAAJA entries which follow, when   *00165000
                         ByAsidJobname is requested                     00166000
         ORG   DLAAHNUMJA                                               00167000
DLAAH#JA DS    F         Same as DLAAHNumJA                             00168000
DLAAHNUMREM DS F         Number of DLAALS or DLAAJA entries which were *00169000
                         not returned because of insufficient space     00170000
         ORG   DLAAHNUMREM                                              00171000
DLAAH#REM DS   F         Same as DLAAHNumREM                            00172000
DLAAHTLEN DS   F         Total length of answer area needed to contain *00173000
                         all the requested information. This includes  *00174000
                         the area for the records that were returned   *00175000
                         on this call.                                  00176000
DLAAHFIRSTLSADDR DS A    Address of first DLAALS                        00177000
         ORG   DLAAHFIRSTLSADDR                                         00178000
DLAAHFIRSTLS@ DS A       Same as FIRSTLSADDR                            00179000
         ORG   DLAAHFIRSTLS@                                            00180000
DLAAHFIRSTJAADDR DS A    Address of first DLAAJA                        00181000
         ORG   DLAAHFIRSTJAADDR                                         00182000
DLAAHFIRSTJA@ DS A       Same as FIRSTJAADDR                            00183000
DLAAHDR_LEN EQU *-DLAAHDR                                               00184000
.L0002   ANOP                                                           00185000
         AIF   ('&DLAALS' EQ 'NO').L0005                                00186000
         AIF   ('&DSECT' EQ 'YES').L0006                                00187000
         AIF   ('&DLAALS' NE 'YES').L0005                               00188000
DLAALS   DS    0F        DLAALS Record data format                      00189000
         AGO   .L0007                                                   00190000
.L0006   ANOP                                                           00191000
DLAALS   DSECT           DLAALS Record data format                      00192000
.L0007   ANOP                                                           00193000
DLAALSNEXTADDR DS A      Address of next DLAALS. DLAAHNumLS must be    *00194000
                         used to determine how far along this chain to *00195000
                         go.                                            00196000
         ORG   DLAALSNEXTADDR                                           00197000
DLAALSNEXT@ DS A         Same as NEXTADDR                               00198000
DLAALSFIRSTDSADDR DS A   Address of first DLAADS for this DLAALS        00199000
         ORG   DLAALSFIRSTDSADDR                                        00200000
DLAALSFIRSTDS@ DS A      Same as FirstDSADDR                            00201000
DLAALSFIRSTUADDR DS A    Address of first DLAAU for this DLAALS         00202000
         ORG   DLAALSFIRSTUADDR                                         00203000
DLAALSFIRSTU@ DS A       Same as FirstUADDR                             00204000
DLAALSNAME DS  CL16      Name of LNKLST set                             00205000
DLAALSFLAGS DS B         Flags                                          00206000
*  Bit definitions:                                                     00207000
DLAALSCURRENT EQU X'80'  This is the current LNKLST                     00208000
DLAALSWASCURRENT EQU X'40' This used to be a current LNKLST and is     *00209000
                         still in use                                   00210000
DLAALSINUSEBYLLA EQU X'20' LLA is monitoring the LNKLST using this     *00211000
                         LNKLST set                                     00212000
         DS    CL3       UNUSED                                         00213000
DLAALSLNKLSTSEQNUM DS F  The SeqNum of this LNKLST set. Only valid     *00214000
                         when this LNKLST set is active. The SeqNum    *00215000
                         remains unchanged when an in-use LNKLST set   *00216000
                         is activated. A larger SeqNum does not        *00217000
                         necessarily indicate a more current           *00218000
                         activation.                                    00219000
         ORG   DLAALSLNKLSTSEQNUM                                       00220000
DLAALSLNKLSTSEQ# DS F    Same as DLAALSLnklstSeqNum                     00221000
         DS    CL4       Unused                                         00222000
DLAALSNUMDS DS H         Number of DLAADS entries associated with this *00223000
                         LNKLST set                                     00224000
         ORG   DLAALSNUMDS                                              00225000
DLAALS#DS DS   H         Same as DLAALSNumDS                            00226000
DLAALSNUMU DS  H         Number of DLAAU entries associated with this  *00227000
                         LNKLST set                                     00228000
         ORG   DLAALSNUMU                                               00229000
DLAALS#U DS    H         Same as DLAALSNumU                             00230000
DLAALS_LEN EQU *-DLAALS                                                 00231000
.L0005   ANOP                                                           00232000
         AIF   ('&DLAADS' EQ 'NO').L0008                                00233000
         AIF   ('&DSECT' EQ 'YES').L0009                                00234000
         AIF   ('&DLAADS' NE 'YES').L0008                               00235000
DLAADS   DS    0F        DLAADS Record data format                      00236000
         AGO   .L000A                                                   00237000
.L0009   ANOP                                                           00238000
DLAADS   DSECT           DLAADS Record data format                      00239000
.L000A   ANOP                                                           00240000
DLAADSNEXTADDR DS A      Address of next DLAADS. DLAALSNumDS must be   *00241000
                         used to determine how far along this chain to *00242000
                         go.                                            00243000
         ORG   DLAADSNEXTADDR                                           00244000
DLAADSNEXT@ DS A         Same as NEXTADDR                               00245000
DLAADSFLAGS DS B         Flags                                          00246000
*  Bit definitions:                                                     00247000
DLAADSAPF EQU  X'80'     APF-authorized. Represents status as of last  *00248000
                         allocation                                     00249000
DLAADSAPFNOTAVAILABLE EQU X'40' APF status is not available. Either    *00250000
                         the data set was not successfully allocated,  *00251000
                         or the LNKLST set itself is not valid.         00252000
DLAADSSMSMANAGED EQU X'20' The data set is SMS-managed. Represents     *00253000
                         status as of last allocation.                  00254000
DLAADSSMSNOTAVAILABLE EQU X'10' SMS status is not available. Either    *00255000
                         the data set was not successfully allocated,  *00256000
                         or the LNKLST set itself is not valid.         00257000
         DS    CL3       UNUSED                                         00258000
DLAADSVOLID DS CL6       Volume ID. Represents status as of last       *00259000
                         allocation                                     00260000
DLAADSNAMELEN DS H       Length of name                                 00261000
DLAADSNAME DS  CL44      Data set name. It will only occupy as much    *00262000
                         space as indicated by DlaadsNameLen            00263000
DLAADS_LEN EQU *-DLAADS                                                 00264000
.L0008   ANOP                                                           00265000
         AIF   ('&DLAAU' EQ 'NO').L000B                                 00266000
         AIF   ('&DSECT' EQ 'YES').L000C                                00267000
         AIF   ('&DLAAU' NE 'YES').L000B                                00268000
DLAAU    DS    0F        DLAAU Record data format                       00269000
         AGO   .L000D                                                   00270000
.L000C   ANOP                                                           00271000
DLAAU    DSECT           DLAAU Record data format                       00272000
.L000D   ANOP                                                           00273000
DLAAUNEXTADDR DS A       Address of next DLAAU. DLAALSNumU must be     *00274000
                         used to determine how far along this chain to *00275000
                         go.                                            00276000
         ORG   DLAAUNEXTADDR                                            00277000
DLAAUNEXT@ DS  A         Same as NEXTADDR                               00278000
DLAAUJOBNAME DS CL8      Job name using this LNKLST set                 00279000
DLAAUASID DS   H         ASID of job                                    00280000
         DS    CL2       UNUSED                                         00281000
DLAAU_LEN EQU  *-DLAAU                                                  00282000
.L000B   ANOP                                                           00283000
         AIF   ('&DLAAJA' EQ 'NO').L000E                                00284000
         AIF   ('&DSECT' EQ 'YES').L000F                                00285000
         AIF   ('&DLAAJA' NE 'YES').L000E                               00286000
DLAAJA   DS    0F        DLAAJA Record data format                      00287000
         AGO   .L0010                                                   00288000
.L000F   ANOP                                                           00289000
DLAAJA   DSECT           DLAAJA Record data format                      00290000
.L0010   ANOP                                                           00291000
DLAAJANEXTADDR DS A      Address of next DLAAJA. DLAALSNumJA must be   *00292000
                         used to determine how far along this chain to *00293000
                         go.                                            00294000
         ORG   DLAAJANEXTADDR                                           00295000
DLAAJANEXT@ DS A         Same as NEXTADDR                               00296000
DLAAJAJOBNAME DS CL8     Job name                                       00297000
DLAAJAASID DS  H         ASID of job                                    00298000
         DS    CL2       UNUSED                                         00299000
DLAAJALSNAME DS CL16     LNKLST set name                                00300000
*                                                                       00301000
*    *****************************************************************  00302000
*    *                                                               *  00303000
*    * Format constants returned for CSVDYNL REQUEST(QUERYDYN)       *  00304000
*    *                                                               *  00305000
*    *****************************************************************  00306000
*                                                                       00307000
*                                                                       00308000
CSVDYNLDYNNOTAVAILABLE EQU 0                                            00309000
CSVDYNLDYNAVAILABLE EQU 1                                               00310000
*                                                                       00311000
*    *****************************************************************  00312000
*    *                                                               *  00313000
*    * Return Code / Reason code constants from CsvDynl. It is       *  00314000
*    * guaranteed that no reason code will be reused (i.e., the same *  00315000
*    * reason code will not be used for more than one return code).  *  00316000
*    * Also note carefully that bits 0-15 of the reason code may     *  00317000
*    * contain component-diagnostic data and must not be assumed to  *  00318000
*    * be 0.                                                         *  00319000
*    *                                                               *  00320000
*    *****************************************************************  00321000
*                                                                       00322000
*                                                                       00323000
CSVDYNLRSNCODEMASK EQU X'0000FFFF' Use this mask to isolate the non    *00324000
                         component-diagnostic portion of the reason    *00325000
                         code.                                          00326000
CSVDYNLRC_OK EQU 0       Return code 0, success                         00327000
CSVDYNLRC_WARN EQU 4     Return code 4, warning                         00328000
*                                                                       00329000
*    *****************************************************************  00330000
*    *                                                               *  00331000
*    * Reason codes for RC=4                                            00332000
*    *                                                               *  00333000
*    *****************************************************************  00334000
*                                                                       00335000
*                                                                       00336000
CSVDYNLRSNROUTINENOTFOUND EQU X'00000402' For TEST request, the        *00337000
                         routine was not found                          00338000
CSVDYNLRSNNOTALLDATARETURNED EQU X'00000403' For LIST, the provided    *00339000
                         output area was not large enough to contain   *00340000
                         all the data.                                  00341000
CSVDYNLRSNNOMATCHINGJOB EQU X'00000406' For UPDATE request, no         *00342000
                         matching job or ASID was found.                00343000
CSVDYNLRC_INVPARM EQU 8  Return code 8, invalid parameter               00344000
*                                                                       00345000
*    *****************************************************************  00346000
*    *                                                               *  00347000
*    * Reason codes for RC=8                                            00348000
*    *                                                               *  00349000
*    *****************************************************************  00350000
*                                                                       00351000
*                                                                       00352000
CSVDYNLRSNBADPARMLIST EQU X'00000801' Error while accessing parameter  *00353000
                         list                                           00354000
CSVDYNLRSNSRBMODE EQU X'00000802' Caller was in SRB mode                00355000
CSVDYNLRSNNOTENABLED EQU X'00000803' Caller was not enabled             00356000
CSVDYNLRSNNOTAUTHORIZED EQU X'00000804' Caller was not authorized       00357000
CSVDYNLRSNHOMENOTPRIMARY EQU X'00000805' HASN ^= PASN                   00358000
CSVDYNLRSNBADANSAREAALET EQU X'00000806' ALET of ANSAREA was not       *00359000
                         acceptable                                     00360000
CSVDYNLRSNBADANSAREA EQU X'00000807' Error while accessing ANSAREA      00361000
CSVDYNLRSNBADANSLEN EQU X'00000808' ANSLEN was not at least as long as *00362000
                         DLAAHDR mapped by CSVDLAA.                     00363000
CSVDYNLRSNBADREQUESTTYPE EQU X'00000809' Parameter list contains an    *00364000
                         incorrect request type. Possible overlay.      00365000
CSVDYNLRSNBADESTAEX EQU X'0000080A' ESTAEX recovery could not be       *00366000
                         established. Possibly the caller had an EUT   *00367000
                         FRR.                                           00368000
CSVDYNLRSNRESERVEDNOT0 EQU X'0000080B' Parameter list contains a non-0 *00369000
                         value in a reserved field. Possible overlay.   00370000
CSVDYNLRSNBADPARMLISTALET EQU X'0000080D' ALET of parameter list was   *00371000
                         not acceptable.                                00372000
CSVDYNLRSNBADVERSION EQU X'0000080E' Parameter list contains an        *00373000
                         incorrect version number. Possible overlay.    00374000
CSVDYNLRSNLOCKED EQU X'0000080F' Caller held a system lock.             00375000
CSVDYNLRSNBADDSNAMEAREA EQU X'00000815' Error while accessing area     *00376000
                         containing DSNAME                              00377000
CSVDYNLRSNBADAFTERDSNAMEAREA EQU X'00000816' Error while accessing     *00378000
                         area containing AFTERDSNAME                    00379000
CSVDYNLRSNBADOPEN EQU X'00000818' Unable to open supplied data set.     00380000
CSVDYNLRSNLNKLSTSETNOTFOUND EQU X'00000819' LNKLST set does not exist   00381000
CSVDYNLRSNDATASETNOTFOUND EQU X'0000081C' For DELETE, data set was not *00382000
                         in the LNKLST set. For ADD, "after" data set  *00383000
                         was not in the LNKLST set.                     00384000
CSVDYNLRSNBADDSNAMEALET EQU X'00000820' ALET of area containing DSNAME *00385000
                         is not acceptable                              00386000
CSVDYNLRSNBADAFTERDSNAMEALET EQU X'00000821' ALET of area containing   *00387000
                         AFTERDSNAME is not acceptable                  00388000
CSVDYNLRSNBADLNKLSTNAME EQU X'00000822' LNKLST set name begins with    *00389000
                         blank or hex zero                              00390000
CSVDYNLRSNBADDSNAME EQU X'00000823' DSNAME begins with blank or hex    *00391000
                         zero                                           00392000
CSVDYNLRSNBADAFTERDSNAME EQU X'00000824' AFTERDSNAME begins with blank *00393000
                         or hex zero                                    00394000
CSVDYNLRSNBADALLOC EQU X'00000829' Unable to allocate requested data   *00395000
                         set                                            00396000
CSVDYNLRSNFUNCTIONNOTAVAILABLEERROR EQU X'0000082B' Function requested *00397000
                         when dynamic allocation is not allowed by the *00398000
                         system (or function requested during NIP).     00399000
CSVDYNLRSNRESERVEDNAME EQU X'00000831' Reserved name "CURRENT" or      *00400000
                         "IPL" was used on a DEFINE, ADD, or DELETE    *00401000
                         request.                                       00402000
CSVDYNLRSNNOJOBASID EQU X'00000832' The job name was blank (or null)   *00403000
                         and the ASID was 0 for UPDATE or LIST          00404000
CSVDYNLRSNADDSYSDSN EQU X'00000833' A request was made to add the      *00405000
                         LINKLIB, MIGLIB, CSSLIB, LINKLIBE, or MIGLIBE *00406000
                         data set, or to add after one of those data   *00407000
                         sets.                                          00408000
CSVDYNLRSNDELETESYSDSN EQU X'00000834' A request was made to delete    *00409000
                         the LINKLIB, MIGLIB, CSSLIB, LINKLIBE, or     *00410000
                         MIGLIBE data set.                              00411000
CSVDYNLRSNNOCOPYFROM EQU X'00000835' Could not locate the COPYFROM     *00412000
                         LNKLST set.                                    00413000
CSVDYNLRSNALREADYEXISTS EQU X'00000836' For DEFINE request, LNKLST set *00414000
                         already exists. For ADD request, data set was *00415000
                         already associated with this LNKLST set.       00416000
CSVDYNLRSNNOMODNAME EQU X'00000837' Module name was null                00417000
CSVDYNLRSNCONCATFULL EQU X'00000839' Attempt to ADD a data set but the *00418000
                         concatenation is full.                         00419000
CSVDYNLRSNBADPROBDSNAMEAREA EQU X'0000083A' Error while accessing area *00420000
                         to contain probdsname                          00421000
CSVDYNLRSNBADPROBDSNAMEALET EQU X'0000083B' ALET of area to contain    *00422000
                         PROBDSNAME is not acceptable                   00423000
CSVDYNLRSNNOTPARTITIONED EQU X'0000083C' The data set is not           *00424000
                         partitioned.                                   00425000
CSVDYNLRSNBADVOLID EQU X'0000083D' The provided VolID does not match   *00426000
                         the one in the catalog.                        00427000
CSVDYNLRSNMULTIVOLUME EQU X'0000083E' IEFDDSRV's output was not as     *00428000
                         expected. The data set is multi-volume.        00429000
CSVDYNLRSNMISSINGSYSDSN EQU X'0000083F' The LNKLST set being tested    *00430000
                         does not contain at least one of              *00431000
                         SYS1.LINKLIB, SYS1.MIGLIB, SYS1.CSSLIB.       *00432000
                         SYS1.SIEALNKE, and SYS1.SIEAMIGE. This should *00433000
                         occur only if you used the SYSLIB statement   *00434000
                         of PROGxx.                                     00435000
CSVDYNLRSNUNDEFINECURRENT EQU X'00000840' An attempt was made to       *00436000
                         UNDEFINE the current LNKLST set.               00437000
CSVDYNLRSNBADFOUNDDSNAMEAREA EQU X'00000841' Error while accessing     *00438000
                         area to contain FoundDsname                    00439000
CSVDYNLRSNBADFOUNDDSNAMEALET EQU X'00000842' ALET of area to contain   *00440000
                         FoundDsname is not acceptable                  00441000
CSVDYNLRSNBADSMS EQU X'00000843' The SMS status of the data set has    *00442000
                         changed. Either it is now SMS-managed but had *00443000
                         not been, or it is not SMS-managed but had    *00444000
                         been.                                          00445000
CSVDYNLRC_ENV EQU 12     Return code 12, environmental error            00446000
*                                                                       00447000
*    *****************************************************************  00448000
*    *                                                               *  00449000
*    * Reason codes for RC=12                                           00450000
*    *                                                               *  00451000
*    *****************************************************************  00452000
*                                                                       00453000
*                                                                       00454000
CSVDYNLRSNFUNCTIONNOTAVAILABLE EQU X'00000C01'                          00455000
CSVDYNLRSNNOSTORAGE EQU X'00000C02' Storage was not available for a    *00456000
                         system control block                           00457000
CSVDYNLRSNCHANGEINUSE EQU X'00000C03' An attempt was made to change    *00458000
                         (ADD or DELETE) an in-use LNKLST set.          00459000
CSVDYNLRSNUNDEFINEUSERS EQU X'00000C04' An attempt was made to         *00460000
                         UNDEFINE a LNKLST set that is still in use.   *00461000
                         The request is denied.                         00462000
CSVDYNLRSNUNDEFINELLA EQU X'00000C06' An attempt was made to UNDEFINE  *00463000
                         a LNKLST set that is being used by LLA to     *00464000
                         manage the LNKLST. The request is denied.      00465000
CSVDYNLRSNBADIEFDDSRV EQU X'00000C07' Bad return code from IEFDDSRV.   *00466000
                         050201                                         00467000
CSVDYNLRC_COMPERROR EQU 16 Unknown, unexpected error                    00468000
*                                                                       00469000
*    *****************************************************************  00470000
*    *                                                               *  00471000
*    * Reason codes for RC=16                                           00472000
*    *                                                               *  00473000
*    *****************************************************************  00474000
*                                                                       00475000
*                                    *                                  00476000
*                                                                       00477000
CSVDYNLRSNCOMPERROR EQU X'00001001' System error encountered by        *00478000
                         component.                                     00479000
DLAAJA_LEN EQU *-DLAAJA                                                 00480000
.L000E   ANOP                                                           00481000
         AIF   ('&ZCBPRINT' EQ 'NO').P3                                 00482000
         AIF   ('&LIST' EQ 'YES').P4                                    00483000
.P3      ANOP                                                           00484000
         POP   PRINT                                                    00485000
.P4      ANOP                                                           00486000
.P_EXIT  ANOP                                                           00487000
         MEND                                                           00488000
**/ CSVDLAA_2:;                                                         00489000
* %CSVDLAA_INCLUDED = 'YES';                                            00490000
* %DCL ZCBPRINT CHAR EXT;                                               00491000
* %DEACTIVATE ZCBPRINT;                                                 00492000
* %DCL CSVDLAA_LIST CHAR EXT;                                           00493000
* %DEACTIVATE CSVDLAA_LIST;                                             00494000
* %IF CSVDLAA_LIST ^= 'NO' &                                            00495000
*    ZCBPRINT ^= 'NO' %THEN                                             00496000
*   %GOTO CSVDLAA_3;                                                    00497000
*   @LIST PUSH NOECHO;                                                  00498000
*   @LIST NOASSEMBLE NOECHO;                                            00499000
*   @LIST OFF C NOECHO;                                                 00500000
* %CSVDLAA_3:;                                                          00501000
*/* Start of PL/X Source                                             */ 00502000
* %SELECT(DLAAHDR_BASED);          /*                            @L1A*/ 00503000
*   %WHEN('')                      /* Not specified?             @L1A*/ 00504000
*     %DLAAHDR_BASED = 'BASED(*)'; /* Default to simply based    @L1A*/ 00505000
*   %WHEN('NO')                    /* Don't want it based?       @L1A*/ 00506000
*       %DLAAHDR_BASED = '';       /* Nullify the basing expression     00507000
*                                                                @L1A*/ 00508000
*   %OTHERWISE %;                  /* Else leave what user supplied     00509000
*                                                                @L1A*/ 00510000
* %END SELECT;                     /*                            @L1A*/ 00511000
*%IF DLAA_ALET = '' %THEN /*                                     @L1A*/ 00512000
*  %DLAA_ALET = '0';       /*                                    @L1A*/ 00513000
*%DLAA_VIA='';            /*                                     @L1A*/ 00514000
*%IF DLAA_ALET^='0' %THEN  /*                                    @L1A*/ 00515000
*  %DLAA_VIA='VIA(DLAA_ALET)';   /*                              @L1A*/ 00516000
*DCL 1 DLAAHDR DLAAHDR_BASED DLAA_VIA, /* Header section         @L1A*/ 00517000
*     2 DLAAHNumLS FIXED(32),/* Number of DLAALS entries which follow   00518000
*                                                                @L1A*/ 00519000
*      3 DLAAH#LS FIXED(32),/* Same as DLAAHNumLS                    */ 00520000
*       4 DLAAHNumJA FIXED(32),/* Number of DLAAJA entries which        00521000
*                     follow, when ByAsidJobname is requested    @L1A*/ 00522000
*        5 DLAAH#JA FIXED(32),/* Same as DLAAHNumJA              @L1A*/ 00523000
*     2 DLAAHNumREM FIXED(32),/* Number of DLAALS or DLAAJA             00524000
*                             entries which were not returned because   00525000
*                             of insufficient space              @L1A*/ 00526000
*     3 DLAAH#REM FIXED(32),/* Same as DLAAHNumREM               @L1A*/ 00527000
*     2 DLAAHTLEN FIXED(32),/* Total length of answer area needed to    00528000
*                             contain all the requested information.    00529000
*                             This includes the area for the records    00530000
*                             that were returned on this call.   @L1A*/ 00531000
*     2 DLAAHFIRSTLSADDR PTR(31), /* Address of first DLAALS     @LxA*/ 00532000
*      3 DLAAHFIRSTLS@ PTR(31), /* Same as FIRSTLSADDR           @LxC*/ 00533000
*       4 DLAAHFIRSTJAADDR PTR(31), /* Address of first DLAAJA   @LxA*/ 00534000
*        5 DLAAHFIRSTJA@ PTR(31), /* Same as FIRSTJAADDR         @LxC*/ 00535000
*     2 * CHAR(0) BDY(WORD);   /* Word-align the ending          @L1A*/ 00536000
* %SELECT(DLAALS_BASED);           /*                            @L1A*/ 00537000
*   %WHEN('')                      /* Not specified?             @L1A*/ 00538000
*     %DLAALS_BASED = 'BASED(*)'; /* Default to simply based     @L1A*/ 00539000
*   %WHEN('NO')                    /* Don't want it based?       @L1A*/ 00540000
*       %DLAALS_BASED = '';        /* Nullify the basing expression     00541000
*                                                                @L1A*/ 00542000
*   %OTHERWISE %;                  /* Else leave what user supplied     00543000
*                                                                @L1A*/ 00544000
* %END SELECT;                     /*                            @L1A*/ 00545000
*DCL 1 DLAALS DLAALS_BASED DLAA_VIA, /* DLAALS Record data format       00546000
*                                                                @L1A*/ 00547000
*     2 DLAALSNEXTADDR PTR(31), /* Address of next DLAALS. DLAAHNumLS   00548000
*          must be used to determine how far along this chain to go.    00549000
*                                                                @LxA*/ 00550000
*       3 DLAALSNEXT@ PTR(31), /* Same as NEXTADDR               @LxC*/ 00551000
*     2 DLAALSFirstDSADDR PTR(31), /* Address of first DLAADS for this  00552000
*                                   DLAALS                       @L1A*/ 00553000
*       3 DLAALSFirstDS@ PTR(31), /* Same as FirstDSADDR         @LxA*/ 00554000
*     2 DLAALSFirstUADDR PTR(31), /* Address of first DLAAU for this    00555000
*                                   DLAALS                       @L1A*/ 00556000
*       3 DLAALSFirstU@ PTR(31),     /* Same as FirstUADDR       @LxA*/ 00557000
*     2 DLAALSNAME CHAR(16),  /* Name of LNKLST set              @L1A*/ 00558000
*     2 DLAALSFLAGS BIT(8),   /* Flags                           @L1A*/ 00559000
*       3 DLAALSCurrent BIT(1), /* This is the current LNKLST    @L1A*/ 00560000
*       3 DLAALSWasCurrent BIT(1),  /* This used to be a current        00561000
*              LNKLST and is still in use                        @L1A*/ 00562000
*       3 DLAALSInUseByLLA BIT(1),  /* LLA is monitoring the LNKLST     00563000
*              using this LNKLST set                             @L1A*/ 00564000
*     2 * CHAR(3),            /* UNUSED                          @L1A*/ 00565000
*     2 DLAALSLnklstSeqNum FIXED(32), /* The SeqNum of this LNKLST set. 00566000
*              Only valid when this LNKLST set is active.               00567000
*              The SeqNum remains unchanged when an in-use LNKLST set   00568000
*              is activated.  A larger SeqNum does not necessarily      00569000
*              indicate a more current activation.                      00570000
*                                                                @P1C*/ 00571000
*       3 DLAALSLnklstSeq# FIXED(32), /* Same as DLAALSLnklstSeqNum  */ 00572000
*     2 * CHAR(4),            /* Unused                          @L1A*/ 00573000
*     2 DLAALSNumDS FIXED(16), /* Number of DLAADS entries associated   00574000
*                               with this LNKLST set             @L1A*/ 00575000
*       3 DLAALS#DS FIXED(16), /* Same as DLAALSNumDS            @L1A*/ 00576000
*     2 DLAALSNumU FIXED(16), /* Number of DLAAU entries associated     00577000
*                               with this LNKLST set             @L1A*/ 00578000
*       3 DLAALS#U FIXED(16), /* Same as DLAALSNumU              @L1A*/ 00579000
*     2 * CHAR(0) Bdy(Word);  /* Word-align the ending           @L1A*/ 00580000
* %SELECT(DLAADS_BASED);           /*                            @L1A*/ 00581000
*   %WHEN('')                      /* Not specified?             @L1A*/ 00582000
*     %DLAADS_BASED = 'BASED(*)'; /* Default to simply based     @L1A*/ 00583000
*   %WHEN('NO')                    /* Don't want it based?       @L1A*/ 00584000
*       %DLAADS_BASED = '';        /* Nullify the basing expression     00585000
*                                                                @L1A*/ 00586000
*   %OTHERWISE %;                  /* Else leave what user supplied     00587000
*                                                                @L1A*/ 00588000
* %END SELECT;                     /*                            @L1A*/ 00589000
*DCL 1 DLAADS DLAADS_BASED DLAA_VIA, /* DLAADS Record data format       00590000
*                                                                @L1A*/ 00591000
*     2 DLAADSNEXTADDR PTR(31), /* Address of next DLAADS. DLAALSNumDS  00592000
*          must be used to determine how far along this chain to go.    00593000
*                                                                @L1A*/ 00594000
*       3 DLAADSNEXT@ PTR(31),   /* Same as NEXTADDR             @LxA*/ 00595000
*     2 DLAADSFLAGS BIT(8),   /* Flags                           @L1A*/ 00596000
*       3 DLAADSApf BIT(1),   /* APF-authorized. Represents             00597000
*                                status as of last allocation    @L1A*/ 00598000
*       3 DLAADSApfNotAvailable BIT(1),  /* APF status is not           00599000
*                                available. Either the data set was     00600000
*                                not successfully allocated, or the     00601000
*                                LNKLST set itself is not valid. @L1A*/ 00602000
*       3 DLAADSSmsManaged BIT(1),  /* The data set is SMS-managed.     00603000
*                                Represents status as of last           00604000
*                                allocation.                     @L1A*/ 00605000
*       3 DLAADSSmsNotAvailable BIT(1),  /* SMS status is not           00606000
*                                available. Either the data set was     00607000
*                                not successfully allocated, or the     00608000
*                                LNKLST set itself is not valid. @L1A*/ 00609000
*     2 * CHAR(3),            /* UNUSED                          @L1A*/ 00610000
*     2 DLAADSVOLID CHAR(6),  /* Volume ID. Represents                  00611000
*                                status as of last allocation    @L1A*/ 00612000
*     2 DLAADSNAMELEN FIXED(15) UNSIGNED,  /* Length of name     @L1A*/ 00613000
*     2 DLAADSNAME CHAR(44),  /* Data set name. It will only occupy     00614000
*               as much space as indicated by DlaadsNameLen      @L1A*/ 00615000
*     2 * CHAR(0) Bdy(Word);  /* Word-align the ending           @L1A*/ 00616000
*                                                                       00617000
* %SELECT(DLAAU_BASED);            /*                            @L1A*/ 00618000
*   %WHEN('')                      /* Not specified?             @L1A*/ 00619000
*     %DLAAU_BASED = 'BASED(*)'; /* Default to simply based      @L1A*/ 00620000
*   %WHEN('NO')                    /* Don't want it based?       @L1A*/ 00621000
*       %DLAAU_BASED = '';         /* Nullify the basing expression     00622000
*                                                                @L1A*/ 00623000
*   %OTHERWISE %;                  /* Else leave what user supplied     00624000
*                                                                @L1A*/ 00625000
* %END SELECT;                     /*                            @L1A*/ 00626000
*DCL 1 DLAAU DLAAU_BASED DLAA_VIA, /* DLAAU Record data format   @L1A*/ 00627000
*     2 DLAAUNEXTADDR PTR(31), /* Address of next DLAAU. DLAALSNumU     00628000
*          must be used to determine how far along this chain to go.    00629000
*                                                                @L1A*/ 00630000
*       3 DLAAUNEXT@ PTR(31),   /* Same as NEXTADDR              @LxA*/ 00631000
*     2 DLAAUJOBNAME CHAR(8), /* Job name using this LNKLST set  @L1A*/ 00632000
*     2 DLAAUASID FIXED(15),  /* ASID of job                     @L1A*/ 00633000
*     2 * CHAR(2),            /* UNUSED                          @L1A*/ 00634000
*     2 * CHAR(0) Bdy(Word);  /* Word-align the ending           @L1A*/ 00635000
*                                                                       00636000
* %SELECT(DLAAJA_BASED);           /*                            @L1A*/ 00637000
*   %WHEN('')                      /* Not specified?             @L1A*/ 00638000
*     %DLAAJA_BASED = 'BASED(*)'; /* Default to simply based     @L1A*/ 00639000
*   %WHEN('NO')                    /* Don't want it based?       @L1A*/ 00640000
*       %DLAAJA_BASED = '';        /* Nullify the basing expression     00641000
*                                                                @L1A*/ 00642000
*   %OTHERWISE %;                  /* Else leave what user supplied     00643000
*                                                                @L1A*/ 00644000
* %END SELECT;                     /*                            @L1A*/ 00645000
*DCL 1 DLAAJA DLAAJA_BASED DLAA_VIA, /* DLAAJA Record data format       00646000
*                                                                @L1A*/ 00647000
*     2 DLAAJANEXTADDR PTR(31), /* Address of next DLAAJA. DLAALSNumJA  00648000
*          must be used to determine how far along this chain to go.    00649000
*                                                                @L1A*/ 00650000
*       3 DLAAJANEXT@ PTR(31),   /* Same as NEXTADDR             @LxA*/ 00651000
*     2 DLAAJAJOBNAME CHAR(8), /* Job name                       @L1A*/ 00652000
*     2 DLAAJAASID FIXED(15), /* ASID of job                     @L1A*/ 00653000
*     2 * CHAR(2),            /* UNUSED                          @L1A*/ 00654000
*     2 DLAAJALSNAME CHAR(16), /* LNKLST set name                @L1A*/ 00655000
*     2 * CHAR(0) Bdy(Word);  /* Word-align the ending           @L1A*/ 00656000
*                                                                       00657000
*    /* Format constants returned for CSVDYNL REQUEST(QUERYDYN)      */ 00658000
*DCL CsvdynlDynNotAvailable Fixed(8) Constant(0);             /* @L1A*/ 00659000
*DCL CsvdynlDynAvailable Fixed(8) Constant(1);                /* @L1A*/ 00660000
*                                                                       00661000
*    /* Return Code / Reason code constants from CsvDynl.            */ 00662000
*                                                                       00663000
*    /* It is guaranteed that                                           00664000
*       no reason code will be reused (i.e., the same reason code       00665000
*       will not be used for more than one return code).            */  00666000
*                                                                       00667000
*    /* Also note carefully that bits 0-15 of the reason code           00668000
*       may contain component-diagnostic data and must not be           00669000
*       assumed to be 0.                                            */  00670000
*                                                                       00671000
*Dcl CsvDynlRsnCodeMask Bit(32) Constant('0000FFFF'X); /* Use this      00672000
*               mask to isolate the non component-diagnostic            00673000
*               portion of the reason code.                      @L1A*/ 00674000
*DCL CsvDynlRC_OK Constant(0);      /* Return code 0, success    @L1A*/ 00675000
*DCL CsvDynlRC_WARN Constant(4);    /* Return code 4, warning    @L1A*/ 00676000
*    /* Reason codes for RC=4                                    @L1A*/ 00677000
*Dcl CsvdynlRsnRoutineNotFound Bit(32) Constant('00000402'X); /* For    00678000
*                   TEST request, the routine was not found      @L1A*/ 00679000
*Dcl CsvdynlRsnNotAllDataReturned Bit(32) Constant('00000403'X); /*     00680000
*                   For LIST, the provided output area was              00681000
*                   not large enough to contain all the data.    @L1A*/ 00682000
*Dcl CsvdynlRsnNoMatchingJob Bit(32) Constant('00000406'X); /* For      00683000
*                   UPDATE request, no matching job or ASID was         00684000
*                   found.                                       @L1A*/ 00685000
*Dcl CsvdynlRsnActivateInUse Bit(32) Constant('00000407'X); /* For      00686000
*                   ACTIVATE request, the LNKLST set was already        00687000
*                   in use.                                      @L1A*/ 00688000
*DCL CsvdynlRC_InvParm Constant(8); /* Return code 8,                   00689000
*                                      invalid parameter         @L1A*/ 00690000
*                                   /*                           @L1A*/ 00691000
*    /* Reason codes for RC=8                                    @L1A*/ 00692000
*Dcl CsvdynlRsnBadParmList Bit(32) Constant('00000801'X); /* Error      00693000
*                   while accessing parameter list               @L1A*/ 00694000
*Dcl CsvdynlRsnSRBMode Bit(32) Constant('00000802'X); /* Caller was     00695000
*                   in SRB mode                                  @L1A*/ 00696000
*Dcl CsvdynlRsnNotEnabled Bit(32) Constant('00000803'X); /* Caller      00697000
*                   was not enabled                              @L1A*/ 00698000
*Dcl CsvdynlRsnNotAuthorized Bit(32) Constant('00000804'X); /* Caller   00699000
*                   was not authorized                           @L1A*/ 00700000
*Dcl CsvdynlRsnHomeNotPrimary Bit(32) Constant('00000805'X); /*         00701000
*                   HASN ^= PASN                                 @L1A*/ 00702000
*Dcl CsvdynlRsnBadAnsareaALET Bit(32) Constant('00000806'X); /* ALET    00703000
*                   of ANSAREA was not acceptable                @L1A*/ 00704000
*Dcl CsvdynlRsnBadAnsarea Bit(32) Constant('00000807'X); /* Error       00705000
*                   while accessing ANSAREA                      @L1A*/ 00706000
*Dcl CsvdynlRsnBadAnsLen Bit(32) Constant('00000808'X); /* ANSLEN       00707000
*                   was not at least as long as DLAAHDR mapped by       00708000
*                   CSVDLAA.                                     @L1A*/ 00709000
*Dcl CsvdynlRsnBadRequestType Bit(32) Constant('00000809'X); /*         00710000
*                   Parameter list contains an incorrect request type.  00711000
*                   Possible overlay.                            @L1A*/ 00712000
*DCL CsvdynlRsnBadEstaex Bit(32) Constant('0000080A'X); /* ESTAEX       00713000
*                   recovery could not be established. Possibly the     00714000
*                   caller had an EUT FRR.                       @L1A*/ 00715000
*DCL CsvdynlRsnReservedNot0 Bit(32) Constant('0000080B'X); /*           00716000
*                   Parameter list contains a non-0 value in a reserved 00717000
*                   field. Possible overlay.                     @L1A*/ 00718000
*DCL CsvdynlRsnBadParmlistAlet Bit(32) Constant('0000080D'X); /* ALET   00719000
*                   of parameter list was not acceptable.        @L1A*/ 00720000
*DCL CsvdynlRsnBadVersion Bit(32) Constant('0000080E'X); /*             00721000
*                   Parameter list contains an incorrect version        00722000
*                   number. Possible overlay.                    @L1A*/ 00723000
*DCL CsvdynlRsnLocked Bit(32) Constant('0000080F'X);     /* Caller      00724000
*                   held a system lock.                          @L1A*/ 00725000
*DCL CsvdynlRsnBadDsnameArea Bit(32) Constant('00000815'X); /* Error    00726000
*                   while accessing area containing DSNAME       @L1A*/ 00727000
*DCL CsvdynlRsnBadAfterDsnameArea Bit(32) Constant('00000816'X); /*     00728000
*                   Error                                               00729000
*                   while accessing area containing AFTERDSNAME  @L1A*/ 00730000
*DCL CsvdynlRsnBadOpen     Bit(32) Constant('00000818'X); /* Unable     00731000
*                   to open supplied data set.                   @L1A*/ 00732000
*DCL CsvdynlRsnLnklstSetNotFound Bit(32)                                00733000
*               Constant('00000819'X);     /* LNKLST set does not       00734000
*                   exist                                        @L1A*/ 00735000
*DCL CsvdynlRsnDatasetNotFound Bit(32)                                  00736000
*               Constant('0000081C'X);     /* For DELETE, data set      00737000
*                   was not in the LNKLST set. For ADD, "after" data    00738000
*                   set was not in the LNKLST set.               @L1A*/ 00739000
*DCL CsvdynlRsnBadDsnameALET Bit(32)                                    00740000
*               Constant('00000820'X);     /* ALET of area containing   00741000
*                   DSNAME is not acceptable                     @L1A*/ 00742000
*DCL CsvdynlRsnBadAfterDsnameALET Bit(32)                               00743000
*               Constant('00000821'X);     /* ALET of area containing   00744000
*                   AFTERDSNAME is not acceptable                @L1A*/ 00745000
*DCL CsvdynlRsnBadLnklstName Bit(32)                                    00746000
*               Constant('00000822'X);     /* LNKLST set name begins    00747000
*                   with blank or hex zero                       @L1A*/ 00748000
*DCL CsvdynlRsnBadDsname Bit(32)                                        00749000
*               Constant('00000823'X);     /* DSNAME begins with        00750000
*                   blank or hex zero                            @L1A*/ 00751000
*DCL CsvdynlRsnBadAfterDsname Bit(32)                                   00752000
*               Constant('00000824'X);     /* AFTERDSNAME begins with   00753000
*                   blank or hex zero                            @L1A*/ 00754000
*DCL CsvdynlRsnBadAlloc       Bit(32)                                   00755000
*               Constant('00000829'X);  /* Unable to allocate           00756000
*                   requested data set                           @L1A*/ 00757000
*DCL CsvdynlRsnFunctionNotAvailableError Bit(32)                        00758000
*               Constant('0000082B'X);     /* Function requested        00759000
*               when dynamic allocation is not allowed by the           00760000
*               system (or function requested during NIP).              00761000
*                                                                @L1A*/ 00762000
*DCL CsvdynlRsnReservedName Bit(32)                                     00763000
*               Constant('00000831'X);  /* Reserved name                00764000
*               "CURRENT" or "IPL" was used on a DEFINE, ADD, or        00765000
*               DELETE request.                                         00766000
*                                                                @L1A*/ 00767000
*DCL CsvdynlRsnNoJobASID Bit(32)                                        00768000
*               Constant('00000832'X);  /* The job name was blank (or   00769000
*               null) and the ASID was 0 for UPDATE or LIST             00770000
*                                                                @L1A*/ 00771000
*DCL CsvdynlRsnAddSysdsn BIT(32)                                        00772000
*               Constant('00000833'X);  /* A request was made to add    00773000
*               the LINKLIB, MIGLIB, CSSLIB, LINKLIBE, or               00774000
*               MIGLIBE data set, or to add after one of those          00775000
*               data sets.                                              00776000
*                                                                @L1A*/ 00777000
*DCL CsvdynlRsnDeleteSysdsn BIT(32)                                     00778000
*               Constant('00000834'X);  /* A request was made to        00779000
*               delete the LINKLIB, MIGLIB, CSSLIB, LINKLIBE,           00780000
*               or MIGLIBE data set.                                    00781000
*                                                                @L1A*/ 00782000
*DCL CsvdynlRsnNoCopyFROM BIT(32)                                       00783000
*               Constant('00000835'X);  /* Could not locate the         00784000
*               COPYFROM LNKLST set.                                    00785000
*                                                                @L1A*/ 00786000
*Dcl CsvdynlRsnAlreadyExists Bit(32) Constant('00000836'X); /*          00787000
*                   For DEFINE request, LNKLST set already exists.      00788000
*                   For ADD request, data set was already associated    00789000
*                   with this LNKLST set.                        @L1A*/ 00790000
*DCL CsvdynlRsnNoModname BIT(32)                                        00791000
*               Constant('00000837'X);  /* Module name was null         00792000
*                                                                @L1A*/ 00793000
*DCL CsvdynlRsnConcatFull BIT(32)                                       00794000
*               Constant('00000839'X);  /* Attempt to ADD a data set    00795000
*                      but the concatenation is full.            @L1A*/ 00796000
*DCL CsvdynlRsnBadProbDsnameArea BIT(32)                                00797000
*               Constant('0000083A'X);  /* Error while accessing        00798000
*                      area to contain probdsname                @L1A*/ 00799000
*DCL CsvdynlRsnBadProbDsnameALET BIT(32)                                00800000
*               Constant('0000083B'X);  /* ALET of area to contain      00801000
*                      PROBDSNAME is not acceptable              @L1A*/ 00802000
*DCL CsvdynlRsnNotPartitioned BIT(32)                                   00803000
*               Constant('0000083C'X);  /* The data set is not          00804000
*                      partitioned.                              @L1A*/ 00805000
*DCL CsvdynlRsnBadVolid BIT(32)                                         00806000
*               Constant('0000083D'X);  /* The provided VolID does not  00807000
*                      match the one in the catalog.             @L1A*/ 00808000
*                                                                       00809000
*DCL CsvdynlRsnMultiVolume BIT(32)                                      00810000
*               Constant('0000083E'X);  /* IEFDDSRV's output was        00811000
*                      not as expected. The data set is                 00812000
*                      multi-volume.                             @L1A*/ 00813000
*DCL CsvdynlRsnMissingSysDSN BIT(32)                                    00814000
*               Constant('0000083F'X);  /* The LNKLST set being         00815000
*      tested does not contain at least                                 00816000
*      one of SYS1.LINKLIB, SYS1.MIGLIB, SYS1.CSSLIB. SYS1.SIEALNKE,    00817000
*      and SYS1.SIEAMIGE. This should occur only                        00818000
*      if you used the SYSLIB statement of PROGxx.                      00819000
*                                                                @L1A*/ 00820000
*DCL CsvdynlRsnUndefineCurrent BIT(32)                                  00821000
*               Constant('00000840'X);  /* An attempt was made to       00822000
*                   UNDEFINE the current LNKLST set.                    00823000
*                                                                @L1A*/ 00824000
*DCL CsvdynlRsnBadFoundDsnameArea BIT(32)                               00825000
*               Constant('00000841'X);  /* Error while accessing        00826000
*                      area to contain FoundDsname               @L1A*/ 00827000
*DCL CsvdynlRsnBadFoundDsnameALET BIT(32)                               00828000
*               Constant('00000842'X);  /* ALET of area to contain      00829000
*                      FoundDsname is not acceptable             @L1A*/ 00830000
*DCL CsvdynlRsnBadSMS BIT(32)                                           00831000
*               Constant('00000843'X);  /* The SMS status of the data   00832000
*                      set has changed. Either it is now SMS-managed    00833000
*                      but had not been, or it is not SMS-managed       00834000
*                      but had been.                             @L1A*/ 00835000
*                                                                       00836000
*DCL CsvdynlRC_Env Constant(12);    /* Return code 12,                  00837000
*                                      environmental error       @L1A*/ 00838000
*    /* Reason codes for RC=12                                   @L1A*/ 00839000
*Dcl CsvdynlRsnFunctionNotAvailable Bit(32) Constant('00000C01'X);      00840000
*                                   /*                           @L1A*/ 00841000
*DCL CsvdynlRsnNoStorage      Bit(32)                                   00842000
*               Constant('00000C02'X);  /* Storage was not available    00843000
*               for a system control block                       @L1A*/ 00844000
*DCL CsvdynlRsnChangeInUse Bit(32)                                      00845000
*               Constant('00000C03'X);  /* An attempt was made to       00846000
*               change (ADD or DELETE) an in-use LNKLST set.            00847000
*                                                                @L1A*/ 00848000
*DCL CsvdynlRsnUndefineUsers Bit(32)                                    00849000
*               Constant('00000C04'X);  /* An attempt was made to       00850000
*                   UNDEFINE a LNKLST set that is still in use.         00851000
*                   The request is denied.                       @L1A*/ 00852000
*DCL CsvdynlRsnActivateNoENF Bit(32)                                    00853000
*               Constant('00000C05'X);  /* The ENF notification         00854000
*                   associated with REQUEST=ACTIVATE could not          00855000
*                   be done.                                     @L1A*/ 00856000
*DCL CsvdynlRsnUndefineLLA Bit(32)                                      00857000
*               Constant('00000C06'X);  /* An attempt was made to       00858000
*                   UNDEFINE a LNKLST set that is being used by         00859000
*                   LLA to manage the LNKLST.                           00860000
*                   The request is denied.                       @L1A*/ 00861000
*DCL CsvdynlRsnBadIefddsrv Bit(32)                                      00862000
*               Constant('00000C07'X);  /* Bad return code from         00863000
*                   IEFDDSRV.                                 050201*/  00864000
*                                                                       00865000
*DCL CsvdynlRC_CompError Constant(16); /* Unknown, unexpected           00866000
*                                      error                     @L1A*/ 00867000
*                                   /*                           @L1A*/ 00868000
*    /* Reason codes for RC=16                                   @L1A*/ 00869000
*                                   /*                           @L1A*/ 00870000
*Dcl CsvdynlRsnCompError Bit(32) Constant('00001001'X);   /*            00871000
*               System error encountered by component.           @L1A*/ 00872000
* @LOGIC;                                                               00873000
* #PRAGMA TOOL=CBGEN.                                                   00874000
* #USEORG.                                                              00875000
* #DELETE.CsvdynlRsnActivateInUse                                       00876000
* #DELETE.CsvdynlRsnActivateNoENF                                       00877000
* #EPRAGMA.                                                             00878000
* @ENDLOGIC;                                                            00879000
*/* End of PL/X Source                                               */ 00880000
* %IF CSVDLAA_LIST ^= 'NO' &                                            00881000
*    ZCBPRINT ^= 'NO' %THEN                                             00882000
*   %GOTO CSVDLAA_4;                                                    00883000
*   @LIST POP NOECHO;                                                   00884000
* %CSVDLAA_4:;                                                          00885000
* %END;                                                                 00886000
