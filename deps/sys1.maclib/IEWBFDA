**********************************************************************          
**                                                                   *          
**  $MAC(IEWBFDA) COMP(PMB01):                                       *          
**                                                                   *          
**   MACRO NAME: IEWBFDA                                             *          
**                                                                   *          
**   DESCRIPTION: System Interface to The Fast Data Access           *          
**                Module.                                            *          
**                                                                   *          
**   STATUS: HPM7709                                                 *          
**                                                                   *          
**                                                                   *          
**PROPRIETARY V3 STATEMENT                                           *          
**LICENSED MATERIALS - PROPERTY OF IBM                               *          
**5694-A01                                                           *          
**COPYRIGHT IBM CORP. 1993, 2004                                     *          
**END PROPRIETARY V3 STATEMENT                                       *          
**                                                                   *          
**   FUNCTION:                                                       *          
**       This macro provides a system interface to the               *          
**       fast data access API module.                                *          
**                                                                   *          
**                                                                   *          
**   PROCESSING:                                                     *          
**                                                                   *          
**   LOGIC:                                                          *          
**                                                                   *          
**     -  Produce a comment block of all parameters.                 *          
**     -  Insure no positional parameters were specified.            *          
**     -  Validate keywords.                                         *          
**     -  Determine if this is the first or a subsequent call        *          
**     -  If first, generate code to load and branch to IEWBFDAT     *          
**     -  If a subsequent call                                       *          
**      -  Generate code to branch to IEWBFDAT                       *          
**      -  Upon return from IEWBFDAT:                                *          
**      -  If HOLD=YES, ignore DELETE and keep IEWBFDAT in storage   *          
**      -  If HOLD=NO                                                *          
**       -  If DELETE=YES, delete IEWBFDAT from storage              *          
**       -  Else keep IEWBFDAT in storage                            *          
**                                                                   *          
**     ERROR PROCESSING:                                             *          
**                                                                   *          
**       The macro checks:                                           *          
**                                                                   *          
**       -   that no positional parameters are specified             *          
**       -   that all keywords are given only one argument           *          
**       -   that all required keywords are specified                *          
**                                                                   *          
**       If any of the above checks fail, the macro issues a         *          
**       message and a return code of 8.  Processing continues, if   *          
**       possible, so that all syntax errors can be found in one     *          
**       assembly.                                                   *          
**                                                                   *          
**                                                                   *          
**   NOTES:                                                          *          
**                                                                   *          
**     DEPENDENCIES: NONE                                            *          
**                                                                   *          
**                                                                   *          
**     RESTRICTIONS: NONE                                            *          
**                                                                   *          
**   MACRO:                                                          *          
**                                                                   *          
**     PROCESSOR: ASSEMBLER H                                        *          
**     DISTRIBUTION LIBRARY: AMACLIB                                 *          
**     ATTRIBUTES: NONE                                              *          
**                                                                   *          
**-------------------------------------------------------------------*          
**                                                                   *          
**     PURPOSE:                                                      *          
**         Extract data from a program object                        *          
**                                                                   *          
**     LINKAGE:                                                      *          
**                                                                   *          
** <label> IEWBFDA   ENTRYPNT=iewbfdat_module_entry_point            *          
**                   ,MTOKEN=token_issued_by_this_API                *          
**                   ,RETCODE=return_code                            *          
**                   ,RSNCODE=reason_code                            *          
**                   { ,EPTOKEN=program_entry_point_token !          *          
**                    {,DDNAME=ddname                                *          
**                     ,MEMBER=primary_or_alias_name }    !          *          
**                    {,DCBPTR=dcb_pointer                           *          
**                     ,DEPTR=directory_entry_pointer}    !     @L2C *          
**                     ,PATH=pathname                      }>   @L2A *          
**                   ,CLASS=class_name                               *          
**                   <,SECTION=section_name>                         *          
**                   ,AREA=output_buffer                             *          
**                   ,CURSOR=cursor_relative_to_record               *          
**                   ,COUNT=number_of_records_returned               *          
**                   ,HOLD=hold_resources_indicator                  *          
**                   <,DELETE=delete_module_indicator>               *          
**                   <,LOADFAIL=recovery_routine_if_load_fails>      *          
**                   <,SYSTEMDCB=system_dcb_indicator>        @02A   *          
**                   <,NTYPE=Classes!Sections!Compile Units>  @L3A   *          
**                   <,CULIST=Compile unit list>              @L3A   *          
**                   <,RELOC=relocation address>              @L3A   *          
**                   <,MF={S!L!{E,(3-12),label)}}}>                  *          
**                                                                   *          
**                                                                   *          
**   NOTES:                                                          *          
**   =====                                                           *          
**                                                                   *          
**        A) In the following context, the acronym "API" has the     *          
**           extended meaning of Fast Data Access Application        *          
**           Programming Interface.                                  *          
**                                                                   *          
**        B) Registers specified for keyword arguments               *          
**           must be enclosed in parentheses.                        *          
**                                                                   *          
**        C) In the following variable descriptions, the "varying"   *          
**           attribute for character strings means that the          *          
**           strings must be preceded by a two-byte length field.    *          
**                                                                   *          
**                                                                   *          
**     ENTRYPNT=iewbfdat_module_entry_point                          *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 4-byte variable which contains the entry point       *          
**         address of the IEWBFDAT module.  If the entry point is    *          
**         known prior to the invocation of this macro, then         *          
**         this variable should contain such value.  Otherwise this  *          
**         variable should be set to bynary zeroes so that the macro *          
**         can determine the entry point.                            *          
**                                                                   *          
**         NOTE:  This parameter must not be modified in subsequent  *          
**                calls to the API, once this macro or the caller    *          
**                has determined a valid entry point.                *          
**                                                                   *          
**     MTOKEN = token_issued_by_this_API                             *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 4-byte variable which contains the Module Token      *          
**         established by the API.                                   *          
**                                                                   *          
**         NOTE:  This parameter must be set to binary zeroes before *          
**                the first invocation of the API.                   *          
**                This parameter must not be modified in subsequent  *          
**                calls to the API.                                  *          
**                                                                   *          
**     RETCODE = return_code                                         *          
**                                                                   *          
**         Specifies the name of a full-word hexadecimal string      *          
**         which will receive the API's reason code.                 *          
**                                                                   *          
**                                                                   *          
**     RSNCODE = reason_code                                         *          
**                                                                   *          
**         Specifies the name of a full-word integer variable        *          
**         which will receive the API's completion code.             *          
**                                                                   *          
**                                                                   *          
**     EPTOKEN = program_entry_point_token                           *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of an 8-byte variable which contains the EPTOKEN          *          
**         determined by means of the CSVQUERY macro.  The EPTOKEN   *          
**         is used to locate the correct copy of a module in a PDSE  *          
**         library when the module has already been loaded into      *          
**         virtual storage by the API.                               *          
**                                                                   *          
**         NOTE:  This parameter is mutually exclusive with          *          
**         ====   DDNAME, MEMBER, PATH, DCBPTR, and DEPTR        @L2C*          
**                                                                   *          
**                                                                   *          
**     DDNAME = ddname                                               *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of an 8-byte varying character string which contains the  *          
**         DDNAME associated with the the data set to be accessed.   *          
**                                                                   *          
**         NOTES:                                                    *          
**         =====                                                     *          
**               A) This parameter is mutually exclusive with        *          
**                  EPTOKEN, PATH, DCBPTR, and DEPTR.            @L2C*          
**                                                                   *          
**               B) It requires the MEMBER parameter.                *          
**                                                                   *          
**                                                                   *          
**     MEMBER = primary_or_alias_name                                *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of an 8-byte varying character string which contains the  *          
**         member name or alias of the library member to be          *          
**         accessed.                                                 *          
**                                                                   *          
**         NOTES:                                                    *          
**         =====                                                     *          
**               A) This parameter is mutually exclusive with        *          
**                  EPTOKEN, DCBPTR, and DEPTR.                      *          
**                                                                   *          
**               B) It requires the DDNAME parameter.                *          
**                                                                   *          
**               C) A member name must not be specified in           *          
**                  JCL allocation of the data set identified by     *          
**                  DDNAME.                                          *          
**                                                                   *          
**                                                                   *          
**     DCBPTR = dcb_pointer                                          *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a four-byte pointer variable containing the address of *          
**         a DCB which represents a PDSE program object library.     *          
**                                                                   *          
**         NOTES:                                                    *          
**         =====                                                     *          
**               A) This parameter is mutually exclusive with        *          
**                  EPTOKEN, DDNAME, PATH, and MEMBER.           @L2C*          
**                                                                   *          
**               B) It requires the DEPTR parameter.                 *          
**                                                                   *          
**               C) The DCB it represents must be OPENed prior to    *          
**                  the invocation of the API.  The DCB parameters   *          
**                  at the time of OPEN must be:  DSORG=PO,MACRF=(R) *          
**                                                                   *          
**                                                                   *          
**     DEPTR = directory_entry_pointer                               *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a four-byte pointer variable which contains the        *          
**         address of a single directory entry, which in turn        *          
**         represents the program object library member to be        *          
**         processed.                                                *          
**                                                                   *          
**         NOTES:                                                    *          
**         =====                                                     *          
**               A) This parameter is mutually exclusive with        *          
**                  EPTOKEN, DDNAME, PATH, and MEMBER.           @L2C*          
**                                                                   *          
**               B) It requires the DCBPTR parameter.                *          
**                                                                   *          
**               C) The format of the directory entry represented    *          
**                  by this parameter is that returned by the        *          
**                  BLDL macro.                                      *          
**                                                                   *          
**                                                                   *          
**     PATH   = pathname                                         @L2A*          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of an 1024-byte varying character string which contains   *          
**         the PATH associated with the the data set to be accessed. *          
**                                                                   *          
**         NOTES:                                                    *          
**         =====                                                     *          
**               A) This parameter is mutually exclusive with        *          
**                  EPTOKEN, DDNAME, DCBPTR, and DEPTR.              *          
**                                                                   *          
**     CLASS = class_name                                            *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of an 16-byte varying character string which contains the *          
**         class name of the required data.  The class can be        *          
**         any of the Program Management Binder class names.         *          
**                                                                   *          
**                                                                   *          
**     SECTION = section_name                                        *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 1024-byte varying character string which contains    *          
**         the name of the section to be accessed.                   *          
**                                                                   *          
**         NOTE:  This is an optional parameter and will default     *          
**         ====   to a concatenation of all sections in the          *          
**                specified class.                                   *          
**                                                                   *          
**                                                                   *          
**     AREA = output_buffer                                          *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a standard buffer which will receive the data.         *          
**         The format of the buffer is the same as that required     *          
**         by the Program Management Binder API, GETData.            *          
**                                                                   *          
**                                                                   *          
**     CURSOR = cursor_relative_to_record                            *          
**                                                                   *          
**         Specifies the name of a full-word integer variable        *          
**         which indicates the position, relative to record,         *          
**         where the API should begin processing.                    *          
**                                                                   *          
**         NOTE:                                                     *          
**         ====                                                      *          
**             A) CURSOR is relative to records within a             *          
**                specific section.  If no section name              *          
**                was specified on the first invocation,             *          
**                upon return this variable will indicate            *          
**                the record position relative to the last           *          
**                section processed by the API.                      *          
**                                                                   *          
**             B) A processing error may occur if this value         *          
**                is modified by the caller on subsequent            *          
**                calls to obtain the same kind of data.             *          
**                The request for more data will only be             *          
**                honored if the modified CURSOR value falls         *          
**                within the range of records contained by           *          
**                the last section processed.  If this condition     *          
**                is not met, the RETURN and REASON codes will       *          
**                reflect the error.                                 *          
**                                                                   *          
**                                                                   *          
**     COUNT = number_of_records_returned                            *          
**                                                                   *          
**         Specifies the name of a full-word integer variable        *          
**         which will receive the number of record entries           *          
**         returned by the API in the provided AREA (output_         *          
**         buffer)                                                   *          
**                                                                   *          
**                                                                   *          
**     HOLD = hold_resources_indicator                               *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 1-byte character field.                              *          
**         It indicates whether or not more requests for data from   *          
**         the same module will follow.                              *          
**                                                                   *          
**         Yes and No must be specified as "Y" and "N",              *          
**         respectively.  There is no default value.                 *          
**                                                                   *          
**         If Yes is specified, all obtained resources will be       *          
**         kept in order to satisfy subsequent requests for more     *          
**         data.                                                     *          
**                                                                   *          
**     DELETE = delete_module_indicator                              *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 1-byte character field.                              *          
**         It indicates whether or not the IEWBFDAT module should be *          
**         deleted from storage by this macro upon return from       *          
**         such module.                                              *          
**                                                                   *          
**         Yes and No must be specified as "Y" and "N",              *          
**         respectively.  This in an optional value and the default  *          
**         value is 'Y'.                                             *          
**                                                                   *          
**         The relation to the HOLD parameter is as follows:         *          
**                                                                   *          
**         If HOLD=YES, ignore DELETE and keep IEWBFDAT in storage   *          
**         If HOLD=NO                                                *          
**          If DELETE=YES, delete IEWBFDAT from storage              *          
**          Else keep IEWBFDAT in storage                            *          
**                                                                   *          
**     LOADFAIL = recovery_routine_if_load_fails                     *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a four-byte pointer variable which contains the        *          
**         address of a user-defined routine that would take         *          
**         execution control should the LOAD macro fail while        *          
**         attempting to load the IEWBFDAT module.                   *          
**                                                                   *          
**         If no value is specified and the LOAD macro fails, the    *          
**         user's task will terminate abnormally.                    *          
**                                                                   *          
**         NOTE:  This is an optional parameter.                     *          
**         ====                                                      *          
**                                                                   *          
**     SYSTEMDCB = system_dcb_indicator                 11@02A       *          
**                                                                   *          
**         Specifies the name (RX-type address or register (3)-(12)) *          
**         of a 1-byte character field.                              *          
**         It indicates whether the user has passed a system dcb     *          
**         in the DCB parameter.                                     *          
**                                                                   *          
**         Yes and No must be specified as "Y" and "N",              *          
**         respectively.  There is no default value.                 *          
**                                                                   *          
**         If Yes is specified, the user must be authorized.         *          
**                                                                   *          
**     NTYPE = Section!Class!Compile Units                    @L3A   *          
**                                                                   *          
**         Specifies the type of names to be returned.        @L3A   *          
**         Specifying SECTION causes the names of all sections@L3A   *          
**         in module to be returned.  Specifying CLASS        @L3A   *          
**         causes the names of all classes in the module      @L3A   *          
**         to be returned.  Specifying Compile Units          @L3A   *          
**         causes compile unit information to be returned.    @L3A   *          
**         The value of NTYPE may be abbreviated as           @L3A   *          
**         S ! C ! U.                                         @L3A   *          
**                                                                   *          
**     CULIST= culist                                         @L3A   *          
**                                                                   *          
**         Specifies a structure consisting of a count field  @L3A   *          
**         indicating the number of compile unit entries      @L3A   *          
**         which follow.  Compile unit numbers are            @L3A   *          
**         associated with sections in the module.            @L3A   *          
**                                                                   *          
**     RELOC = relocation address                             @L3A   *          
**                                                                   *          
**         Specifies an eight byte address to be used in      @L3A   *          
**         adcon relocation during processing of text classes.@L3A   *          
**                                                                   *          
**     MF= {S!                                                       *          
**          L!                                                       *          
**          {(E,{(2-12)!label}}}                                     *          
**                                                                   *          
**         First argument - keyword "S", "L", "E"                    *          
**                          or default to "S" when MF is ommitted    *          
**                                                                   *          
**         Second argument, if MF=E - regs 2-12 or RX-Type Address   *          
**         NOTE that reg1 is not allowed as this second argument.    *          
**                                                                   *          
**                                                                   *          
**         The MF (Macro Form) keyword specifies how the macro       *          
**         should generate its code.                                 *          
**         Invalid keyword checking, based on function specified,    *          
**         is done for all macro formats.                            *          
**                                                                   *          
**         S, the Standard form, will check for all required         *          
**         and invalid keywords.  This form generates                *          
**         a complete inline expansion of the parameter list.        *          
**         Control is then transferred to the Fast Data Access       *          
**         API routine.                                              *          
**         The Standard form  is for programs that are not           *          
**         re-entrant, or for programs that do not change values     *          
**         in the parameter list.                                    *          
**                                                                   *          
**         L  specifies the List form of the macro. This form        *          
**         generates a remote parameter list.  Registers are         *          
**         invalid arguments for MF=L format since executable code   *          
**         generation does not occur, only adcons are generated.     *          
**         If a register is specified, and adcon of zero is          *          
**         generated.                                                *          
**                                                                   *          
**         E  specifies the Execute form of the macro.  This form    *          
**         updates the remote parameter list (MF=L) and transfers    *          
**         control to the Fast Data Access API routine.              *          
**         A second parameter is required.                           *          
**                                                                   *          
**         The second parameter for MF=E format is the address of    *          
**         the plist created by the MF=L IEWBFDA invocation.  This   *          
**         parameter must be specified as either a RX type of address*          
**         (possibly the label from MF=L macro invocation) or a      *          
**         register enclosed in parentheses.                         *          
**                                                                   *          
**                                                                   *          
** ----------------------------------------------------------------  *          
**                                                                   *          
**   EXIT NORMAL:                                                    *          
**                                                                   *          
**     RETURN CODE: 0                                                *          
**                                                                   *          
**   EXIT ERRORS:                                                    *          
**                                                                   *          
**     RETURN CODE: 8                                                *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    NO POSITIONAL ARGUMENTS ARE ALLOWED ON THIS    *          
**                    MACRO.                                         *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    KEYWORD MF MUST BE "S", "L", "E", OR           *          
**                    OMITTED.  VALUE "value" IS INVALID.  THIS      *          
**                    VALUE WILL BE IGONORED FOR SYNTAX CHECKING.    *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    KEYWORD "MF=S" MUST HAVE EXACTLY 1 ARGUMENT    *          
**                    WHEN SPECIFIED. "args_specified" ARGUMENTS     *          
**                    WERE SPECIFIED.                                *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    KEYWORD "MF=L" MUST HAVE EXACTLY 1 ARGUMENT    *          
**                    WHEN SPECIFIED. "args_specified" ARGUMENTS     *          
**                    WERE SPECIFIED.                                *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    KEYWORD "MF=E" MUST HAVE 2 ARGUMENTS.          *          
**                    "args_specified"  ARGUMENT(S) WERE SPECIFIED.  *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    THE SECOND ARGUMENT OF KEYWORD "MF=(E,..."     *          
**                    WAS NOT SPECIFIED, BUT IT IS REQUIRED.         *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    THE SECOND ARGUMENT OF KEYWORD "MF=(E,..."     *          
**                    MAY NOT BE REGISTER 1.                         *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    ONLY ONE VALUE MAY BE SPECIFIED FOR KEYWORD    *          
**                    "parm_name", BUT "values_specified" ARGUMENTS  *          
**                    WERE FOUND.                                    *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    "parm_name" IS A REQUIRED PARAMETER BUT NO     *          
**                    ARGUMENT WAS PROVIDED.                         *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                    "EPTOKEN" WAS SPECIFIED AND THEREFORE YOU      *          
**                    CANNOT SPECIFY "DDNAME", "MEMBER", "DCBPTR",   *          
**                    OR "DEPTR"                                     *          
**                                                                   *          
**       REASON CODE: NONE                                           *          
**        MESSAGE:                                                   *          
**                                                                   *          
**                    YOU MUST SPECIFY 1) "EPTOKEN", 2) "DDNAME" AND *          
**                    "MEMBER", OR 3) "DCBPTR" AND "DEPTR"           *          
**                                                                   *          
**   EXTERNAL REFERENCES:                                            *          
**                                                                   *          
**     MACROS:                                                       *          
**       NONE                                                        *          
**                                                                   *          
**   CHANGE ACTIVITY:                                                *          
** $L1=PM2ITER4,HDZ11C0,940915,SJPLSML: Base code                    *          
** $01=OW17155, HDZ11C0,951122,SJPLSML: COMPUWARE's fixes       @01A *          
** $02=OW30712, HDZ11D0,980123,SJPLELA: SYSTEMDCB               @02A *          
** $P0=K160769, HDZ11F0,991116,STLMD  : UPDATE PROLOG           @P0A *          
** $03=OW44717, HDZ11F0,000531,SJPLELA: fix parm list alloc     @03A *          
** $04=OW46856, HDZ11F0,001215,SJPLELA: turn on hi-order bit in @04A *          
**                                      last item in parm list  @04A *          
** $L2=PM4ITER3,HPMB110,010329,SVLNW  : HFS support             @L2A *          
** $L3=DCRA598, HPM7709,020315,SVLEA  : GETN, GETC & GETD func. @L3A *          
**********************************************************************          
         MACRO                                                                  
&LABN IEWBFDA  &ENTRYPNT=,                                             X        
               &MTOKEN=,                                               X        
               &RETCODE=,                                              X        
               &RSNCODE=,                                              X        
               &EPTOKEN=,                                              X        
               &DDNAME=,                                               X        
               &MEMBER=,                                               X        
               &DCBPTR=,                                               X        
               &DEPTR=,                                                X        
               &PATH=,                                          @L2A   X        
               &CLASS=,                                                X        
               &SECTION=,                                              X        
               &AREA=,                                                 X        
               &CURSOR=,                                               X        
               &COUNT=,                                                X        
               &HOLD=,                                                 X        
               &SYSTEMDCB=,                                     @02A   X        
               &NTYPE=,                                         @L3A   X        
               &CULIST=,                                        @L3A   X        
               &RELOC=,                                         @L3A   X        
               &DELETE=,                                               X        
               &LOADFAIL=,                                             X        
               &MF=                                                             
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* SETUP VARIABLES USED THROUGHOUT MACRO                                        
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         LCLA  &I                  LOOP INDEX                                   
         LCLA  &IMAX               MAXIMUM NUMBER OF PARAMETERS                 
         LCLC  &FAIL               EXIT MACRO IF FAIL FLAG SET                  
         LCLC  &INVOC              INVOC=YES IF MF=S OR MF=E                    
         LCLC  &COMPLET            INVOC=YES IF MF=S OR MF=E                    
         LCLC  &PLISTN             PARAMETER LIST LABEL FOR MF=E                
         LCLC  &PLHOLD             PARAMETER LIST HOLD LABEL OFFSET             
         LCLC  &PLDEL              PARAMETER LIST DELETE LABEL OFFSET           
&IMAX    SETA  21                  FOR LOOPING MF PARM EXCLUDED @L3C            
&FAIL    SETC  'NO'                INIT FAIL FLAG AS NO                         
&INVOK   SETC  'YES'               INVOKE IEWBFDAT                              
&COMPLET SETC  'YES'               DEFAULT, REQUIRED PARMS CHECKED              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* VERIFY THE MACRO LABEL, &LABN.  IF BLANK, THEN CREATE A RANDOM ONE.          
.* IT WILL BE USED LATER AS AN ADDRESSING BASE FOR THE PARMLIST.                
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
          LCLC  &MCLBL                                                          
&MCLBL    SETC  '&LABN'                                                         
&LABLEN   SETA  K'&LABN                                                         
          AIF  ('&LABLEN' NE '0').MACLABOK                                      
&MCLBL    SETC  'IEWF&SYSNDX'                                                   
.MACLABOK ANOP                                                                  
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* CHECK FOR POSITIONAL ARGUMENTS                                               
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (N'&SYSLIST EQ 0).NOPOS ANY NON-KEYWORD ARGUMENTS ?              
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'NO POSITIONAL ARGUMENTS ARE ALLOWED ON THIS MACRO.'           
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* VARIABLES USED FOR KEYWORD MF CHECKING                                       
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.NOPOS   LCLC  &MF1                FIRST MF PARAMETER                           
         LCLA  &MFARGS             NUMBER OF MF ARGUMENTS SPECIFIED             
         LCLC  &MF2E               MF=E 2ND PARAM MF=(E,X                       
         LCLC  &MF2E1              MF=E SECOND PAREN, MF=(E,(                   
&MF1     SETC  '&MF(1)'            GET MF IF SPECIFIED                          
         AIF   ('&MF1' NE '').MFSET                                             
&MF1     SETC  'S'                     DEFAULT TO 'S' IF NOT SPECIFIED          
&MFARGS  SETA  1                   NUMBER OF MF PARAMETERS                      
         AGO   .CHKMF                                                           
.MFSET   ANOP                                                                   
&MFARGS  SETA  N'&MF               NUMBER OF MF PARAMETERS                      
.* CHECK MF KEYWORD, DEFAULTS TO MF=S                                           
.CHKMF   AIF   ('&MF1' EQ 'S').MFS,    GO CHECK MF=S                   X        
               ('&MF1' EQ 'L').MFL,    GO CHECK MF=L                   X        
               ('&MF1' EQ 'E').MFE     GO CHECK MF=E                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* MF=?   INVALID MF VALUE SPECIFIED                                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'KEYWORD "MF" MUST BE "S", "L", "E", OR OMITTED.  VALUX        
               E "&MF1" IS INVALID. THIS VALUE WILL BE IGNORED FOR SYNTX        
               AX CHECKING.'                                                    
&MF1     SETC  'S'                     USE MF=S TO DO SYNTAX CHECKING           
         AGO   .ENDMF                  DONE MF KEYWORD CHECKING                 
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* MF=S   WAS SPECIFIED OR ALLOWED TO DEFAULT                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.MFS     ANOP                                                                   
         AIF   (&MFARGS EQ 1).MFSOK                                             
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'KEYWORD "MF=S" MUST HAVE EXACTLY 1 ARGUMENT WHEN SPECX        
               IFIED. "&MFARGS" ARGUMENTS WERE SPECIFIED.'                      
.MFSOK   ANOP                                                                   
&PLISTN  SETC  '&MCLBL'                                                         
&PLHOLD  SETC  '&MCLBL'.'+56'                                                   
&PLDEL   SETC  '&MCLBL'.'+76'          @L3C                                     
         AGO   .ENDMF                  DONE MF KEYWORD CHECKING                 
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* MF=L  WAS SPECIFIED                                                          
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.MFL     ANOP                                                                   
&COMPLET SETC  'NO'                    PARAMETER CHECKING NOT REQUIRED          
&INVOC   SETC  'NO'                    MF=L SO DON'T INVOKE                     
         AIF   (&MFARGS EQ 1).ENDMF                                             
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'KEYWORD "MF=L" MUST HAVE EXACTLY 1 ARGUMENT,  "&MFARGX        
               S" ARGUMENT(S) WERE SPECIFIED.'                                  
         AGO   .ENDMF                  DONE MF KEYWORD CHECKING                 
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* MF=(E,...  WAS SPECIFIED                                                     
.* CHECK FOR VALID PARAMETERS                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.MFE     ANOP                                                                   
         AIF   (&MFARGS EQ 2).COMOK                                             
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'KEYWORD "MF=E" MUST HAVE 2 ARGUMENTS, "&MFARGS" ARGUMX        
               ENT(S) WERE SPECIFIED.'                                          
.COMOK   ANOP                      COMPLETE SPECIFIED OR DEFAULTED TO           
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* SECOND MF=(E,... PARAMETER MAY BE EITHER                                     
.* "(2-12) PLIST ADDRESS REGISTER                                               
.* "label"    VARIABLE CONTAINING ADDRESS OF PLIST OR LABEL FROM MF=L           
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
&MF2E    SETC  '&MF(2)'                                                         
         AIF   ('&MF2E' NE '').MF2EOK                                           
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         MNOTE 8,'THE SECOND ARGUMENT OF KEYWORD "MF=(E,..." WAS NOT SPX        
                ECIFIED, BUT IT IS REQUIRED.'                                   
         AGO   .ENDMF                                                           
.MF2EOK  ANOP                                                                   
&MF2E1   SETC  '&MF(2)'(1,1)      GET FIRST CHARACTER FOR PAREN CHECK           
.* CHECK 2ND MF=E ARGUMENT - {(reg)!label} - REG1 NOT ALLOWED                   
.* BECAUSE IT GETS DESTROYED BY THE MACROS WE INVOKE HERE                       
         AIF   ('&MF2E' NE '(1)').MFE2CHK                                       
         MNOTE 8,'THE SECOND ARGUMENT OF KEYWORD "MF(E,..." MAY NOT BE X        
               REGISTER 1.'                                                     
&FAIL    SETC  'YES'                   REMEMBER UNSUCCESSFUL                    
         AGO   .ENDMF                                                           
.*       IS = (reg)  ?                                                          
.MFE2CHK AIF   ('&MF2E1' NE '(').GENLA                                          
.*       REMOVE PARENS WHEN DO LR                                               
&PLISTN  SETC   '52(,'.'&MF(2,1)'.')'                                           
&MCLBL   LR    1,&MF(2,1)                                                       
&COMPLET SETC  'NO'                    PARAMETER CHECKING NOT REQUIRED          
         AGO   .ENDMF              MF CHECKING DONE                             
.*       ELSE IS VARIABLE/LABEL                                                 
.GENLA   ANOP                                                                   
&PLISTN  SETC   '&MF2E'                                                         
&PLHOLD  SETC   '&MF2E'.'+56'                                                   
&PLDEL   SETC   '&MF2E'.'+76'                      @L3C                         
&MCLBL   LA    1,&MF2E                                                          
.ENDMF   ANOP                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* CREATE STATIC VARIABLES FOR USE AS ARRAY INDICES,                            
.* ONE FOR EVERY ALLOWED PARAMETER                                              
.* ALL ARRAYS AND CHARACTER STRINGS IN THIS MACRO WILL USE THIS                 
.* SAME ORDER                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
&IENTRYPNT        SETA    1                                                     
&IMTOKEN          SETA    2                                                     
&IRETCODE         SETA    3                                                     
&IRSNCODE         SETA    4                                                     
&IEPTOKEN         SETA    5                                                     
&IDDNAME          SETA    6                                                     
&IPATH            SETA    6                                     @L2A            
&IMEMBER          SETA    7                                                     
&IDCBPTR          SETA    8                                                     
&IDEPTR           SETA    9                                                     
&ICLASS           SETA    10                                                    
&ISECTION         SETA    11                                                    
&IAREA            SETA    12                                                    
&ICURSOR          SETA    13                                                    
&ICOUNT           SETA    14                                                    
&IHOLD            SETA    15                                                    
&ISYSTEMDCB       SETA    16                                    @02A            
&INTYPE           SETA    17                                    @L3A            
&ICULIST          SETA    18                                    @L3A            
&IRELOC           SETA    19                                    @L3A            
&IDELETE          SETA    20                                    @L3C            
&ILOADFAIL        SETA    21                                    @L3C            
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &PARMNAM ARRAY ELEMENTS TO EQUAL KEYWORD NAME                           
.*  TO BE USED MAINLY IN MNOTE ERROR MESSAGES FOR MSG CLARITY                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLC    &PARMNAME(21)                                  @L3C            
.*                                                                              
&PARMNAME(&IENTRYPNT)       SETC    '"ENTRYPNT"'                                
&PARMNAME(&IMTOKEN)         SETC    '"MTOKEN"'                                  
&PARMNAME(&IRETCODE)        SETC    '"RETCODE"'                                 
&PARMNAME(&IRSNCODE)        SETC    '"RSNCODE"'                                 
&PARMNAME(&IEPTOKEN)        SETC    '"EPTOKEN"'                                 
&PARMNAME(&IDDNAME)         SETC    '"DDNAME"'                                  
&PARMNAME(&IMEMBER)         SETC    '"MEMBER"'                                  
&PARMNAME(&IDCBPTR)         SETC    '"DCBPTR"'                                  
&PARMNAME(&IDEPTR)          SETC    '"DEPTR"'                                   
         AIF ('&PATH' EQ '').SKIP1                              @L2A            
&PARMNAME(&IPATH)           SETC    '"PATH"'                    @L2A            
.SKIP1   ANOP                                                   @L2A            
&PARMNAME(&ICLASS)          SETC    '"CLASS"'                                   
&PARMNAME(&ISECTION)        SETC    '"SECTION"'                                 
&PARMNAME(&IAREA)           SETC    '"AREA"'                                    
&PARMNAME(&ICURSOR)         SETC    '"CURSOR"'                                  
&PARMNAME(&ICOUNT)          SETC    '"COUNT"'                                   
&PARMNAME(&IHOLD)           SETC    '"HOLD"'                                    
         AIF ('&SYSTEMDCB' EQ '').NTYPE1                        @L3A            
&PARMNAME(&ISYSTEMDCB)      SETC    '"SYSTEMDCB"'               @02A            
.NTYPE1  ANOP                                                   @L2A            
         AIF ('&NTYPE' EQ '').CULIST1                           @L3A            
&PARMNAME(&INTYPE)          SETC    '"NTYPE"'                   @L3A            
.CULIST1  ANOP                                                  @L3A            
         AIF ('&CULIST' EQ '').RELOC1                           @L3A            
&PARMNAME(&ICULIST)         SETC    '"CULIST"'                  @L3A            
.RELOC1   ANOP                                                  @L3A            
         AIF ('&RELOC' EQ '').DELETE1                           @L3A            
&PARMNAME(&IRELOC)          SETC    '"RELOC"'                   @L3A            
.DELETE1  ANOP                                                  @L3A            
&PARMNAME(&IDELETE)         SETC    '"DELETE"'                                  
&PARMNAME(&ILOADFAIL)       SETC    '"LOADFAIL"'                                
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &ARGVAL ARRAY ELEMENTS TO VALUE OF EACH ARGUMENT IF SPECIFIED.          
.*  IF THE ARGUMENT WAS SPECIFIED IN PARENS, THESE WILL BE RETAINED             
.*  IN THE &ARGVAL ELEMENT. PARENS DENOTE REGISTERS.                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLC  &ARGVAL(21)                                      @L3C            
.*                                                                              
&ARGVAL(&IMTOKEN)           SETC    '&MTOKEN'                                   
&ARGVAL(&IENTRYPNT)         SETC    '&ENTRYPNT'                                 
&ARGVAL(&IRETCODE)          SETC    '&RETCODE'                                  
&ARGVAL(&IRSNCODE)          SETC    '&RSNCODE'                                  
&ARGVAL(&IEPTOKEN)          SETC    '&EPTOKEN'                                  
&ARGVAL(&IDDNAME)           SETC    '&DDNAME'                                   
&ARGVAL(&IMEMBER)           SETC    '&MEMBER'                                   
&ARGVAL(&IDCBPTR)           SETC    '&DCBPTR'                                   
&ARGVAL(&IDEPTR)            SETC    '&DEPTR'                                    
         AIF ('&PATH' EQ '').SKIP2                              @L2A            
&ARGVAL(&IPATH)             SETC    '&PATH'                     @L2A            
.SKIP2   ANOP                                                   @L2A            
&ARGVAL(&ICLASS)            SETC    '&CLASS'                                    
&ARGVAL(&ISECTION)          SETC    '&SECTION'                                  
&ARGVAL(&IAREA)             SETC    '&AREA'                                     
&ARGVAL(&ICURSOR)           SETC    '&CURSOR'                                   
&ARGVAL(&ICOUNT)            SETC    '&COUNT'                                    
&ARGVAL(&IHOLD)             SETC    '&HOLD'                                     
         AIF ('&SYSTEMDCB' EQ '').NTYPE2                        @L3A            
&ARGVAL(&ISYSTEMDCB)        SETC    '&SYSTEMDCB'                @02A            
.NTYPE2  ANOP                                                   @L3A            
         AIF ('&NTYPE' EQ '').CULIST2                           @L3A            
&ARGVAL(&INTYPE)            SETC    '&NTYPE'                    @L3A            
.CULIST2 ANOP                                                   @L3A            
         AIF ('&CULIST' EQ '').RELOC2                           @L3A            
&ARGVAL(&ICULIST)           SETC    '&CULIST'                   @L3A            
.RELOC2  ANOP                                                   @L3A            
         AIF ('&RELOC' EQ '').DELETE2                           @L3A            
&ARGVAL(&IRELOC)            SETC    '&RELOC'                    @L3A            
.DELETE2 ANOP                                                   @L3A            
&ARGVAL(&IDELETE)           SETC    '&DELETE'                                   
&ARGVAL(&ILOADFAIL)         SETC    '&LOADFAIL'                                 
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &ARGNUM ARRAY ELEMENTS TO THE NUMBER OF PARAMETERS                      
.*  SPECIFIED FOR EACH KEYWORD. EXPECTED VALUES ARE 1 OR ZERO.                  
.*  USED IN LOOP1 TO VERIFY THAT EITHER 0 OR 1 PARAMETER WAS                    
.*  SPECIFIED FOR EACH KEYWORD.                                                 
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLA  &ARGNUM(21)                                      @L3C            
.*                                                                              
&ARGNUM(&IENTRYPNT)         SETA N'&ENTRYPNT                                    
&ARGNUM(&IMTOKEN)           SETA N'&MTOKEN                                      
&ARGNUM(&IRETCODE)          SETA N'&RETCODE                                     
&ARGNUM(&IRSNCODE)          SETA N'&RSNCODE                                     
&ARGNUM(&IEPTOKEN)          SETA N'&EPTOKEN                                     
&ARGNUM(&IDDNAME)           SETA N'&DDNAME                                      
&ARGNUM(&IMEMBER)           SETA N'&MEMBER                                      
&ARGNUM(&IDCBPTR)           SETA N'&DCBPTR                                      
&ARGNUM(&IDEPTR)            SETA N'&DEPTR                                       
         AIF ('&PATH' EQ '').SKIP3                              @L2A            
&ARGNUM(&IPATH)             SETA N'&PATH                        @L2A            
.SKIP3   ANOP                                                   @L2A            
&ARGNUM(&ICLASS)            SETA N'&CLASS                                       
&ARGNUM(&ISECTION)          SETA N'&SECTION                                     
&ARGNUM(&IAREA)             SETA N'&AREA                                        
&ARGNUM(&ICURSOR)           SETA N'&CURSOR                                      
&ARGNUM(&ICOUNT)            SETA N'&COUNT                                       
&ARGNUM(&IHOLD)             SETA N'&HOLD                                        
         AIF ('&SYSTEMDCB' EQ '').NTYPE3                        @L3A            
&ARGNUM(&ISYSTEMDCB)        SETA N'&SYSTEMDCB                   @02A            
.NTYPE3  ANOP                                                   @L3A            
         AIF ('&NTYPE' EQ '').CULIST3                           @L3A            
&ARGNUM(&INTYPE)            SETA N'&NTYPE                       @L3A            
.CULIST3 ANOP                                                   @L3A            
         AIF ('&CULIST' EQ '').RELOC3                           @L3A            
&ARGNUM(&ICULIST)           SETA N'&CULIST                      @L3A            
.RELOC3  ANOP                                                   @L3A            
         AIF ('&RELOC' EQ '').DELETE3                           @L3A            
&ARGNUM(&IRELOC)            SETA N'&RELOC                       @L3A            
.DELETE3 ANOP                                                   @L3A            
&ARGNUM(&IDELETE)           SETA N'&DELETE                                      
&ARGNUM(&ILOADFAIL)         SETA N'&LOADFAIL                                    
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &ARGTYPE ARRAY TO BLANKS.                                               
.*                                                                              
.*  IN LOOP1 WE'LL SET THEM TO 'X' OR 'R', DEPENDING ON THE                     
.*  ATTRIBUTES WE FIND OUT (RX-TYPE ARGUMENT OR REGISTER ARGUMENT)              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLC  &ARGTYPE(21)                                     @L3C            
.*                                                                              
&ARGTYPE(&IENTRYPNT)        SETC ' '                                            
&ARGTYPE(&IMTOKEN)          SETC ' '                                            
&ARGTYPE(&IRETCODE)         SETC ' '                                            
&ARGTYPE(&IRSNCODE)         SETC ' '                                            
&ARGTYPE(&IEPTOKEN)         SETC ' '                                            
&ARGTYPE(&IDDNAME)          SETC ' '                                            
&ARGTYPE(&IMEMBER)          SETC ' '                                            
&ARGTYPE(&IDCBPTR)          SETC ' '                                            
&ARGTYPE(&IDEPTR)           SETC ' '                                            
&ARGTYPE(&ICLASS)           SETC ' '                                            
&ARGTYPE(&ISECTION)         SETC ' '                                            
&ARGTYPE(&IAREA)            SETC ' '                                            
&ARGTYPE(&ICURSOR)          SETC ' '                                            
&ARGTYPE(&ICOUNT)           SETC ' '                                            
&ARGTYPE(&IHOLD)            SETC ' '                                            
&ARGTYPE(&ISYSTEMDCB)       SETC ' '                            @02A            
&ARGTYPE(&INTYPE)           SETC ' '                            @L3A            
&ARGTYPE(&ICULIST)          SETC ' '                            @L3A            
&ARGTYPE(&IRELOC)           SETC ' '                            @L3A            
&ARGTYPE(&IDELETE)          SETC ' '                                            
&ARGTYPE(&ILOADFAIL)        SETC ' '                                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &ARGREQ ARRAY ELEMENTS TO THE TYPE OF EACH PARAMETER.                   
.*                                                                              
.*  A PARAMETER CAN BE REQUIRED OR OPTIONAL  (R ! O)                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLC  &ARGREQ(21)                                      @L3C            
.*                                                                              
&ARGREQ(&IENTRYPNT)         SETC 'R'                                            
&ARGREQ(&IMTOKEN)           SETC 'R'                                            
&ARGREQ(&IRETCODE)          SETC 'R'                                            
&ARGREQ(&IRSNCODE)          SETC 'R'                                            
&ARGREQ(&IEPTOKEN)          SETC 'O'                                            
&ARGREQ(&IDDNAME)           SETC 'O'                                            
&ARGREQ(&IMEMBER)           SETC 'O'                                            
&ARGREQ(&IDCBPTR)           SETC 'O'                                            
&ARGREQ(&IDEPTR)            SETC 'O'                                            
         AIF ('&PATH' EQ '').SKIP4                              @L2A            
&ARGREQ(&IPATH)             SETC 'O'                            @L2A            
.SKIP4   ANOP                                                   @L2A            
&ARGREQ(&ICLASS)            SETC 'O'                            @L3C            
&ARGREQ(&ISECTION)          SETC 'O'                                            
&ARGREQ(&IAREA)             SETC 'R'                                            
&ARGREQ(&ICURSOR)           SETC 'R'                                            
&ARGREQ(&ICOUNT)            SETC 'R'                                            
&ARGREQ(&IHOLD)             SETC 'R'                                            
         AIF ('&SYSTEMDCB' EQ '').NTYPE4                        @L3A            
&ARGREQ(&ISYSTEMDCB)        SETC 'O'                            @02A            
.NTYPE4  ANOP                                                   @L3A            
         AIF ('&NTYPE' EQ '').CULIST4                           @L3A            
&ARGREQ(&INTYPE)            SETC 'O'                            @L3A            
.CULIST4 ANOP                                                   @L3A            
         AIF ('&CULIST' EQ '').RELOC4                           @L3A            
&ARGREQ(&ICULIST)           SETC 'O'                            @L3A            
.RELOC4  ANOP                                                   @L3A            
         AIF ('&RELOC' EQ '').DELETE4                           @L3A            
&ARGREQ(&IRELOC)            SETC 'O'                            @L3A            
.DELETE4 ANOP                                                   @L3A            
&ARGREQ(&IDELETE)           SETC 'O'                                            
&ARGREQ(&ILOADFAIL)         SETC 'O'                                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  SET &OFFSET ARRAY ELEMENTS TO PLIST LABEL VALUE                             
.*  USED IN LOOP3 FOR ST, STC, OI, NI AND MVI INSTRUCTIONS.                     
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLA  &OFFSET(21)                                      @L3C            
.*                                                                              
&OFFSET(&IENTRYPNT)         SETA  0                                             
&OFFSET(&IMTOKEN)           SETA  4                                             
&OFFSET(&IRETCODE)          SETA  8                                             
&OFFSET(&IRSNCODE)          SETA  12                                            
&OFFSET(&IEPTOKEN)          SETA  16                                            
&OFFSET(&IDDNAME)           SETA  20                                            
&OFFSET(&IMEMBER)           SETA  24                                            
&OFFSET(&IDCBPTR)           SETA  28                                            
&OFFSET(&IDEPTR)            SETA  32                                            
&OFFSET(&ICLASS)            SETA  36                                            
&OFFSET(&ISECTION)          SETA  40                                            
&OFFSET(&IAREA)             SETA  44                                            
&OFFSET(&ICURSOR)           SETA  48                                            
&OFFSET(&ICOUNT)            SETA  52                                            
&OFFSET(&IHOLD)             SETA  56                                            
&OFFSET(&ISYSTEMDCB)        SETA  60                            @02C            
&OFFSET(&INTYPE)            SETA  64                            @L3A            
&OFFSET(&ICULIST)           SETA  68                            @L3A            
&OFFSET(&IRELOC)            SETA  72                            @L3A            
&OFFSET(&IDELETE)           SETA  76                            @L3C            
&OFFSET(&ILOADFAIL)         SETA  80                            @L3C            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* CREATE STATIC ARRAY TO CONTAIN PLIST FIELD COMMENTS                          
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         LCLC  &FIELDNAM(21)                                    @L3C            
.*                                                                              
&FIELDNAM(&IENTRYPNT) SETC 'IEWBFDAT_module_entry_ptr'                          
&FIELDNAM(&IMTOKEN)   SETC 'Token_Issued_by_API'                                
&FIELDNAM(&IRETCODE)  SETC 'Return_Code'                                        
&FIELDNAM(&IRSNCODE)  SETC 'Reason_Code'                                        
&FIELDNAM(&IEPTOKEN)  SETC 'Program_Entry_Point_Token'                          
&FIELDNAM(&IDDNAME)   SETC 'DDNAME'                                             
&FIELDNAM(&IMEMBER)   SETC 'Primary_or_Alias_Name'                              
&FIELDNAM(&IDCBPTR)   SETC 'DCB_Pointer'                                        
&FIELDNAM(&IDEPTR)    SETC 'Directory_Entry_Pointer'                            
         AIF ('&PATH' EQ '').SKIP5                              @L2A            
&FIELDNAM(&IPATH)     SETC 'Pathname'                           @L2A            
.SKIP5   ANOP                                                   @L2A            
&FIELDNAM(&ICLASS)    SETC 'Class_Name'                                         
&FIELDNAM(&ISECTION)  SETC 'Section_Name'                                       
&FIELDNAM(&IAREA)     SETC 'Output_Buffer'                                      
&FIELDNAM(&ICURSOR)   SETC 'Cursor_Relative_to_Record'                          
&FIELDNAM(&ICOUNT)    SETC 'Number_of_Records_Returned'                         
&FIELDNAM(&IHOLD)     SETC 'Hold_Resources_Indicator'                           
         AIF ('&SYSTEMDCB' EQ '').NTYPE5                        @L3A            
&FIELDNAM(&ISYSTEMDCB) SETC 'System_DCB'                        @02A            
.NTYPE5  ANOP                                                   @L3A            
         AIF ('&NTYPE' EQ '').CULIST5                           @L3A            
&FIELDNAM(&INTYPE)     SETC 'Ntype'                             @L3A            
.CULIST5 ANOP                                                   @L3A            
         AIF ('&CULIST' EQ '').RELOC5                           @L3A            
&FIELDNAM(&ICULIST)    SETC 'Compile_unit_list'                 @L3A            
.RELOC5  ANOP                                                   @L3A            
         AIF ('&RELOC' EQ '').DELETE5                           @L3A            
&FIELDNAM(&IRELOC)     SETC 'Relocation_address'                @L3A            
.DELETE5 ANOP                                                   @L3A            
&FIELDNAM(&IDELETE)   SETC 'Delete_Module_Indicator'                            
&FIELDNAM(&ILOADFAIL) SETC 'Recovery_Rtn_if_LOAD_fails'                         
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.*  LOOP 1  - "PRESENCE AND ERROR MESSAGE LOOP"                                 
.*                                                                              
.*  - CHECK ALL SPECIFIED KEYWORDS                                              
.*                                                                              
.*  - SET &FAIL FLAG IF ANY KEYWORD ERRORS                                      
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.LOOP1   ANOP                                                                   
.*                                                                              
         LCLA  &ARGLEN           LENGTH OF EACH KEYWORD ARGUMENT                
&I       SETA  0                                                                
.RELOOP1 ANOP                                                                   
&I       SETA  &I+1                                                             
.* ARE WE DONE?                                                                 
         AIF   ('&I' GT '&IMAX').ENDLOP1                EXIT LOOP 1             
.* DETERMINE IF KEYWORD SPECIFIED                                               
         AIF   ('&ARGVAL(&I)' NE '').CHKPARM                                    
.* KEYWORD NOT REQUIRED BECAUSE THIS MF=E                                       
         AIF   ('&MF1' EQ 'E').RELOOP1                                          
.* CHECK NUMBER OF KEYWORD ARGUMENTS SPECIFIED                                  
.CHKPARM AIF   ('&ARGNUM(&I)' EQ '1').CHKREG    IF ONE ARGUMENT                 
         AIF   ('&ARGNUM(&I)' EQ '0').CHKREQ    IF NO  ARGUMENT                 
&FAIL    SETC  'YES'                         IF MORE THAN ONE ARGUMENT          
.*                                                                              
         MNOTE 8,'ONLY ONE VALUE MAY BE SPECIFIED FOR KEYWORD &PARAMNAMX        
               (&I), BUT &ARGNUM(&I) VALUES WERE FOUND.'                        
         AGO   .RELOOP1                                                         
.* IF NO ARGUMENT WAS SPECIFIED FOR A SPECIFIC KEYWORD, MAKE SURE               
.* IT IS NOT ONE OF THE REQUIRED PARAMETERS                                     
.*                                                                              
.* IF IT'S REQUIRED BUT WAS NOT SPECIFIED, THEN ISSUE ERROR MSG                 
.CHKREQ  AIF   ('&ARGREQ(&I)' EQ 'R').ERRMSG                                    
.* IF OPTIONAL, SEE IF IT IS PARAMETER FOR WHICH WE CAN SET A DEFAULT           
.*       AIF   (&I EQ &IDELETE).SETDEL                                          
.* SET THE DEFAULT VALUE FOR THE DELETE PARM, WHICH IS 'Y'                      
.* .SETDEL   ANOP                                                               
.* &ARGVAL(&IDELETE)  SETC  'Y'                                                 
         AGO   .RELOOP1                                                         
.ERRMSG  ANOP                                                                   
&FAIL    SETC  'YES'                                                            
         MNOTE 8,''&PARMNAME(&I)' IS A REQUIRED PARAMETER BUT NO ARGUMEX        
               NT WAS PROVIDED.'                                                
         AGO   .RELOOP1                                                         
.* CHECK FOR REGISTER ARGUMENT                                                  
.* ARGUMENT IS IN A REGISTER IF FIRST CHAR IS '(' AND LAST                      
.*                                                    CHAR IS ')'               
.CHKREG  ANOP                                                                   
.*                                                                              
&ARGLEN  SETA  K'&ARGVAL(&I)                                                    
         AIF   ('&ARGVAL(&I)'(1,1) NE '(').SETRX                                
         AIF   ('&ARGVAL(&I)'(&ARGLEN,1) NE ')').SETRX                          
.*    SET ARGUMENT TYPE TO 'R' FOR REGISTER                                     
.SETR    ANOP                                                                   
&ARGTYPE(&I) SETC  'R'                                                          
         AGO   .RELOOP1                                                         
.*                                                                              
.* ASSUME RX TYPE OF ARGUMENT                                                   
.*                                                                              
.SETRX   ANOP                                                                   
&ARGTYPE(&I) SETC  'X'                                                          
         AGO   .RELOOP1                                                         
.ENDLOP1 ANOP                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* CHECK MUTUALLY EXCLUSIVE KEYS:                                               
.*                                                                              
.* WAS THE EPTOKEN SPECIFIED?                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.CHK1    ANOP                                                                   
         AIF   ('&EPTOKEN' EQ '').CHK2                                          
.* EPTOKEN WAS SPECIFIED, THEREFORE DDNAME, MEMBER, DCBPTR,                     
.* DEPTR, AND PATH MUST BE BLANK                                                
         AIF   (('&DDNAME' EQ '') AND ('&MEMBER' EQ '') AND            X        
               ('&PATH' EQ '') AND                                     X        
               ('&DCBPTR' EQ '') AND ('&DEPTR' EQ '')).EXCLUS     @L2C          
&FAIL    SETC  'YES'                                                            
         MNOTE 8,'"EPTOKEN" WAS SPECIFIED, AND THEREFORE YOU CANNOT SPEX        
               CIFY "DDNAME" , "MEMBER" , "DCBPTR", "DEPTR", OR "PATH"'         
         AGO   .EXCLUS                                            @L2C          
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* EPTOKEN WAS NOT SPECIFIED                                                    
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.CHK2    ANOP                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE DDNAME/MEMBER PAIR WAS SPECIFIED -- LEAVE LOOP                           
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DDNAME' NE '') AND ('&MEMBER' NE '') AND            X        
               ('&PATH' EQ '') AND                                     X        
               ('&DCBPTR' EQ '') AND ('&DEPTR' EQ '')).EXCLUS     @L2C          
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE DDNAME WAS SPECIFIED -- LEAVE LOOP @L2A                                  
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DDNAME' NE '') AND ('&MEMBER' EQ '') AND            X        
               ('&PATH' EQ '') AND                                     X        
               ('&DCBPTR' EQ '') AND ('&DEPTR' EQ '')).EXCLUS     @L2A          
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE DCBPTR/DEPTR PAIR WAS SPECIFIED -- LEAVE LOOP                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DCBPTR' NE '') AND ('&DEPTR' NE '') AND             X        
               ('&PATH' EQ '') AND                                     X        
               ('&DDNAME' EQ '') AND ('&MEMBER' EQ '')).EXCLUS    @L2C          
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE PATH              WAS SPECIFIED -- LEAVE LOOP                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DCBPTR' EQ '') AND ('&DEPTR' EQ '') AND             X        
               ('&PATH' NE '') AND                                     X        
               ('&DDNAME' EQ '') AND ('&MEMBER' EQ '')).EXCLUS    @L2A          
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE DDNAME OR THE MEMBER IS BLANK -- IS THIS THE MF=E FORM?                  
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DDNAME' EQ '') OR ('&MEMBER' EQ '')).CHK3                    
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE DCBPTR OR THE DEPTR IS BLANK -- IS THIS THE MF=E FORM?                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&DCBPTR' EQ '') OR ('&DEPTR' EQ '')).CHK3                     
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* THE PATH                IS BLANK -- IS THIS THE MF=E FORM?     @L2A          
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   (('&PATH'   EQ '')).CHK3                                         
.* KEYWORD NOT REQUIRED BECAUSE THIS MF=E                                       
.CHK3    AIF   ('&MF1' EQ 'E').EXCLUS                                           
&FAIL    SETC  'YES'                                                            
         MNOTE 8,'YOU MUST SPECIFY 1) "EPTOKEN", 2) "DDNAME" AND "MEMBEX        
               R", 3) "DCBPTR" AND "DEPTR", OR 4) "PATH"'                       
.EXCLUS  ANOP                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.* IEWBFDA  MACRO KEYWORD VALIDITY CHECKING DONE.                               
.* IF ERRORS EXIST EXIT. ELSE CONTINUE AND ALL OTHER ERROR                      
.* MESSAGES WILL BE FROM THE ASSEMBLER.                                         
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         AIF   ('&FAIL' EQ 'YES').ENDMAC                                        
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  GEN BRANCH CODE FOR MF=S OR MF=E, GEN PLIST HEADER FOR MF=S OR MF=L         
.*  GEN FUNC CODE                                                               
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.GEN     ANOP                  START GENERATING CODE                            
.*                                                                              
         AIF   ('&MF1' EQ 'E').GENEND     =E                                    
.* HANDLE MF = S                                                                
         AIF   ('&MF1' EQ 'L').GENLL      =L                                    
.* HANDLE MF = L                                                                
         AIF   ('&MF1' EQ 'S').GENLS      =S                                    
.* PRODUCE MF=L EXPANSION                                                       
.GENLL   CNOP  0,4                         WORD ALIGNMENT                       
&MCLBL   DS    0F                                                               
         AGO   .GENEND                                                          
.* PRODUCE MF=S EXPANSION                                                       
.GENLS   CNOP  0,4                                                              
         BAS   1,*+88                      BRANCH AROUND PARM LIST@L3C          
&MCLBL   DC    21A(0)                      RESERVE STRG FOR PARMs@L3C           
.GENEND  ANOP                                                                   
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.*  LOOP 2 - "BUILD INLINE PLIST LOOP"                                          
.*                                                                              
.*  -  DONE FOR MF=L                                                            
.*  -  ENTERED IF NO PREVIOUS KEYWORD ERRORS                                    
.*  -  ISSUE DC ALn(0) FOR KEYWORDS THAT DO NOT EXIST                           
.*  -  ISSUE DC ASSEMBLER STATEMENT FOR KEYWORDS THAT EXIST AND                 
.*     ARE &ARGTYPE (ARGUMENT TYPES SETUP IN LOOP1) OF :                        
.*        'X' - RX TYPE, ASSUMED TO BE NON-EXTERNAL                             
.*                                                                              
.*  -  ISSUE DC AL(HOLD_VALUE+X'80000000') FOR LAST PARM, HOLD                  
.*    OR                                                                        
.*  -  ISSUE DC AL(X'80000000') FOR HOLD, IF NO HOLD VALUE WAS PASSED           
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
         LCLA  &FILLCNT  USED FOR FORMATTING FIELD NAMES                        
&FILLCNT SETA  0                                                                
         LCLA  &STARTP   START PARM, USED FOR FORMATTING FIELD NAMES            
&STARTN  SETA  25                                                               
         AIF   (('&MF1' EQ 'E') OR ('&MF1' EQ 'S')).LOOP3                       
         LCLC  &BLANKS   USED TO PUSH FIELD NAMES TO THE RIGHT                  
&BLANKS  SETC '                                                    '            
         LCLC  &FILLER   USED TO PUSH FIELD NAMES TO THE RIGHT                  
&I       SETA  0                                                                
.RELOOP2 ANOP                                                                   
&I       SETA  &I+1                                                             
         AIF   ('&I' GT '&ILOADFAIL').ENDLOP2       EXIT LOOP 2                 
.*                                                                              
.* CALCULATE FILLER IN ORDER TO FORMAT FIELD NAMES NEATLY                       
&FILLCNT SETA  (&STARTN-K'&ARGVAL(&I))                                          
&FILLER  SETC  '&BLANKS'(1,&FILLCNT)                                            
&FILLCNT2 SETA  (&STARTN-(K'&ARGVAL(&I)+12))                                    
&FILLER2  SETC  '&BLANKS'(1,&FILLCNT2)                                          
&FILLCNT3 SETA  14                                                              
&FILLER3  SETC  '&BLANKS'(1,&FILLCNT3)                                          
&FILLCNT4 SETA  (&STARTN-3)                                                     
&FILLER4  SETC  '&BLANKS'(1,&FILLCNT4)                                          
.*                                                                              
.* HANDLE ARGUMENT TYPE OF RX ADDRESS 'X'                                       
.*                                                                              
         AIF   ('&ARGTYPE(&I)' NE 'X').DOREST                                   
         AIF   (('&I' EQ '&IDELETE') OR ('&I' EQ '&ILOADFAIL')).H4              
         DC    A(&ARGVAL(&I))&FILLER.&FIELDNAM(&I)                              
         AGO   .RELOOP2                                                         
.H4      AIF   ('&ARGVAL(&I)' EQ '').H6                                         
         DC    A(&ARGVAL(&I))&FILLER.&FIELDNAM(&I)                              
         AGO   .RELOOP2                                                         
.H6      DC    AL4(0)&FILLER4.&FIELDNAM(&I)                                     
         AGO   .RELOOP2                                                         
.*                                                                              
.* ELSE ARGUMENT WAS NOT SPECIFIED OR IF WAS FOR MF=S & MF=L                    
.* WILL BE HANDLED BY CODE GENNED IN LOOP3                                      
.*                                                                              
.DOREST  AIF   (('&I' EQ '&ILOADFAIL') OR ('&I' EQ '&IDELETE')).H7              
         DC    AL4(0)&FILLER4.&FIELDNAM(&I)                                     
         AGO   .RELOOP2                                                         
.H7      AIF   ('&I' EQ '&LOADFAIL').H8                                         
         DC    AL4(0)&FILLER4.&FIELDNAM(&I)                                     
         AGO   .RELOOP2                                                         
.H8      ANOP                                                                   
         AGO   .RELOOP2                                                         
.*                                                                              
.ENDLOP2 ANOP                                                                   
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  LOOP 3 - "FILL IN PLIST LOOP"                                               
.*                                                                              
.*  -  FOR MF=E OR MF=S                                                         
.*  -  HANDLE REMOTE PLIST (MF=E) AND IN-LINE PLIST (MF=S)                      
.*  -  ENTERED IF NO PREVIOUS KEYWORD ERRORS                                    
.*  -  MOVE KEYWORD ADDRESSES OR VALUES INTO PLIST                              
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.LOOP3   AIF   ('&MF1' EQ 'L').ENDLOP3                                          
&I       SETA  0                                                                
.RELOOP3 ANOP                                                                   
&I       SETA  &I+1                                                             
         AIF   ('&I' GT '&ILOADFAIL').ENDLOP3       EXIT LOOP 3                 
.*                                                                              
.* HANDLE ARGUMENT TYPE OF REGISTER 'R'                                         
.*                                                                              
.*                                                                              
         AIF   ('&ARGTYPE(&I)' NE 'R').DOX3                                     
         ST    &ARGVAL(&I),&OFFSET(&I)(0,1)                                     
.*                                                        3@04D                 
.H1      AGO   .RELOOP3                                                         
.*                                                                              
.* HANDLE ARGUMENT TYPE OF RX ADDRESS                                           
.*                                                                              
.*                                                                              
.DOX3    AIF   ('&ARGTYPE(&I)' NE 'X').RELOOP3                                  
.*       AIF   ('&MF1' EQ 'S').RELOOP3                                          
         LA    15,&ARGVAL(&I)                                                   
         ST    15,&OFFSET(&I)(0,1)                                              
.*                                                        3@04D                 
.H2      AGO   .RELOOP3                                                         
.*                                                                              
.*                                                                              
.ENDLOP3 ANOP                                                                   
.* SET HIGH ORDER BIT IN LAST PARAMETER                          @04A           
         AIF ('&RELOC' EQ '').SETCU                              @L3A           
         OI    72(1),X'80'                                       @L3A           
         AGO .BITSET                                             @L3A           
.SETCU   ANOP                                                    @L3A           
         AIF ('&CULIST' EQ '').NTYPE                             @L3A           
         OI    68(1),X'80'                                       @L3A           
         AGO .BITSET                                             @L3A           
.NTYPE   ANOP                                                    @L3A           
         AIF ('&NTYPE' EQ '').SYSDCB                             @L3A           
         OI    64(1),X'80'                                       @L3A           
         AGO .BITSET                                             @L3A           
.SYSDCB  ANOP                                                    @L3A           
         AIF ('&SYSTEMDCB' EQ '').SETHOLD                        @L3A           
         OI    60(1),X'80'                                       @L3A           
         AGO .BITSET @L3A                                                       
.SETHOLD ANOP @L3A                                                              
         OI    56(1),X'80'                                       @04A           
.BITSET  ANOP                                                    @L3A           
&LOADFD2 SETC  '(2)'                                                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  END THE MACRO IF WE HAVE TO, AFTER ALL THE TESTS                            
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.CHKINVO ANOP                                                                   
         AIF   ('&FAIL' EQ 'YES').ENDMAC                                        
         AIF   ('&INVOC' EQ 'NO').ENDMAC                                        
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*  GENERATE OUR CALL SEQUENCE FOR THE IEWBFDAT MODULE:                         
.*                                                                              
.*    L    ENTRYPNT                                                             
.*    TEST ENTRYPNT                                                             
.*    IF ZER0                                                                   
.*      LOAD IEWBFDAT MODULE INTO VIRTUAL STORAGE                               
.*     ELSE                                                                     
.*      L  15,ENTRYPNT  (ADDRESS OF LOADED IEWBFDAT)                            
.*    ENDIF                                                                     
.*    BASSM 14,15                                                               
.*                                                                              
.*    TEST HOLD                                                                 
.*    IF HOLD=Y THEN DO NOT DELETE IEWBFDAT MODULE                              
.*    IF HOLD=N THEN                                                            
.*      IF DELETE WAS NOT SPECIFIED OR DELETE IS YES                            
.*        DELETE IEWBFDAT MODULE (FROM VIRTUAL STORAGE)                         
.*        ZERO OUT ENTRYPNT                                                     
.*      ENDIF                                                                   
.*      IF DELETE IS NO                                                         
.*        THEN DO NOT DELETE IEWBFDAT MODULE                                    
.*    ENDIF                                                                     
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         L     14,0(0,1)          LOAD ADDR OF API'S PARM LIST                  
         L     0,0(0,14)          LOAD API'S ENTRYPNT                           
         LTR   0,0                IF ZERO, LOAD THE API INTO STORAGE            
         BNZ   IEWA&SYSNDX                                                      
         LR    14,1               SAVE PARM LIST ADDR IN R14                    
         L     0,&OFFSET(&ILOADFAIL)(0,14) LOAD RECOVERY ROUT PARM @01C         
         LTR   0,0                IF ZERO, LOAD WITH NO RECOVERY                
         BNZ   IEWB&SYSNDX                                                      
         MNOTE  '         LOAD  EP=IEWBFDAT'                                    
         LOAD  EP=IEWBFDAT                                                      
         B     IEWC&SYSNDX                                                      
         MNOTE  '         LOAD  EP=IEWBFDAT,ERRET=&LOADFD2'                     
IEWB&SYSNDX LR    2,0                                             @01C          
            LOAD  EP=IEWBFDAT,ERRET=&LOADFD2                                    
IEWC&SYSNDX LR    1,14            RESTORE PARM LIST ADDR TO R1                  
         L     14,0(0,1)          LOAD ADDR OF THE ENTRYPNT PARM                
         ST    0,0(0,14)          STORE ADDR OF IEWBFDAT IN ENTRYPNT            
IEWA&SYSNDX LR 15,0               LOAD ADDR OF IEWBFDAT INTO R15                
         O     15,=X'80000000'    SET AMODE=31 FOR IEWBFDAT       @01A          
.BRNCH   BASSM 14,15              BRANCH TO IEWBFDAT MODULE                     
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.*    PROCESS THE HOLD AND DELETE PARAMETERS                                    
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
         L     15,&PLHOLD         LOAD THE HOLD PARM                            
         CLI   0(15),C'Y'         IF HOLD=Y                                     
         BE    IEWD&SYSNDX        THEN DO NOT DELETE                            
         L     15,&PLDEL          LOAD THE DELETE PARM                          
         LTR   15,15              TEST FOR VALUE                                
         BZ    IEWE&SYSNDX        IF PARM NOT SPECIFIED THEN DELETE             
         CLI   0(15),C'N'         IF DELETE=N                                   
         BE    IEWD&SYSNDX        THEN DO NOT DELETE                            
         MNOTE  '         DELETE EP=IEWBFDAT'                                   
IEWE&SYSNDX DELETE EP=IEWBFDAT    ELSE DELETE THE MODULE                        
         L     15,&PLISTN         R15 NOW CONTAINS THE ENTRYPNT VALUE           
         XC    0(4,15),0(15)      ZERO OUT THE ENTRYPNT VALUE                   
IEWD&SYSNDX CNOP 0,4                                                            
.*                                                                              
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *          
.*                                                                              
.ENDMAC  ANOP                                                                   
.*                                                                              
         MEND                                                                   
